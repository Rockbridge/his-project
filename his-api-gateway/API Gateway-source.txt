# HIS API Gateway - Complete Source Code Structure
Generated: Mo 11 Aug 2025 23:28:54 CEST
Project: Hospital Information System (HIS) - API Gateway
=========================================================

## Directory Structure
```
./.mvn/wrapper/maven-wrapper.properties
./Dockerfile
./pom.xml
./src/main/java/de/his/gateway/ApiGatewayApplication.java
./src/main/java/de/his/gateway/config/PvsGatewayProperties.java
./src/main/java/de/his/gateway/config/SecurityConfig.java
./src/main/java/de/his/gateway/controller/FallbackController.java
./src/main/java/de/his/gateway/filter/JwtAuthenticationFilter.java
./src/main/java/de/his/gateway/service/JwtService.java
./src/main/resources/application-docker.yml
./src/main/resources/application.yml
```

## Tree Structure
```
.
├── API Gateway-source.txt
├── Dockerfile
├── mvnw
├── mvnw.cmd
├── pom.xml
├── pom.xml.tmp
└── src
    ├── main
    │   ├── java
    │   │   └── de
    │   │       └── his
    │   │           └── gateway
    │   │               ├── ApiGatewayApplication.java
    │   │               ├── config
    │   │               │   ├── PvsGatewayProperties.java
    │   │               │   └── SecurityConfig.java
    │   │               ├── controller
    │   │               │   └── FallbackController.java
    │   │               ├── filter
    │   │               │   └── JwtAuthenticationFilter.java
    │   │               └── service
    │   │                   └── JwtService.java
    │   └── resources
    │       ├── application-docker.yml
    │       └── application.yml
    └── test
        └── java
            └── de
                └── his
                    └── gateway

17 directories, 14 files
```

## Source Code Files

### File: ./src/main/java/de/his/gateway/ApiGatewayApplication.java
```java
package de.his.gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
import org.springframework.context.annotation.Bean;

import java.time.Duration;

/**
 * Main Application Class for HIS API Gateway
 * 
 * Provides centralized routing, authentication, and cross-cutting concerns
 * for the Hospital Information System microservices.
 */
@SpringBootApplication
public class ApiGatewayApplication {

        public static void main(String[] args) {
                SpringApplication.run(ApiGatewayApplication.class, args);
        }

        /**
         * Configures routing rules for microservices
         * 
         * Routes:
         * - /api/v1/patients/** → Patient Service (8081)
         * - /api/v1/encounters/** → Encounter Service (8082)
         * - /actuator/** → Individual service health endpoints
         */
        @Bean
        public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
                return builder.routes()

                                // Patient Service Routes
                                .route("patient-service", r -> r
                                                .path("/api/v1/patients/**")
                                                .filters(f -> f
                                                                .stripPrefix(0) // Keep full path
                                                                .addRequestHeader("X-Gateway-Request",
                                                                                "patient-service")
                                                                .addResponseHeader("X-Gateway-Response",
                                                                                "patient-service")
                                                                .circuitBreaker(config -> config
                                                                                .setName("patient-service-cb")
                                                                                .setFallbackUri("forward:/fallback/patient-service"))
                                                                .retry(config -> config
                                                                                .setRetries(3)
                                                                                .setBackoff(Duration.ofMillis(100),
                                                                                                Duration.ofMillis(1000),
                                                                                                2, true)))
                                                .uri("http://patient-service:8081"))

                                // Encounter Service Routes
                                .route("encounter-service", r -> r
                                                .path("/api/v1/encounters/**")
                                                .filters(f -> f
                                                                .stripPrefix(0) // Keep full path
                                                                .addRequestHeader("X-Gateway-Request",
                                                                                "encounter-service")
                                                                .addResponseHeader("X-Gateway-Response",
                                                                                "encounter-service")
                                                                .circuitBreaker(config -> config
                                                                                .setName("encounter-service-cb")
                                                                                .setFallbackUri("forward:/fallback/encounter-service"))
                                                                .retry(config -> config
                                                                                .setRetries(3)
                                                                                .setBackoff(Duration.ofMillis(100),
                                                                                                Duration.ofMillis(1000),
                                                                                                2, true)))
                                                .uri("http://encounter-service:8082"))

                                // Health Check Routes - Direct pass-through
                                .route("patient-health", r -> r
                                                .path("/services/patient/actuator/**")
                                                .filters(f -> f
                                                                .stripPrefix(2) // Remove /services/patient
                                                                .addResponseHeader("X-Health-Service",
                                                                                "patient-service"))
                                                .uri("http://patient-service:8081"))

                                .route("encounter-health", r -> r
                                                .path("/services/encounter/actuator/**")
                                                .filters(f -> f
                                                                .stripPrefix(2) // Remove /services/encounter
                                                                .addResponseHeader("X-Health-Service",
                                                                                "encounter-service"))
                                                .uri("http://encounter-service:8082"))

                                // API Documentation Routes
                                .route("patient-docs", r -> r
                                                .path("/docs/patient/**")
                                                .filters(f -> f
                                                                .stripPrefix(2) // Remove /docs/patient
                                                                .addResponseHeader("X-Docs-Service", "patient-service"))
                                                .uri("http://patient-service:8081"))

                                .route("encounter-docs", r -> r
                                                .path("/docs/encounter/**")
                                                .filters(f -> f
                                                                .stripPrefix(2) // Remove /docs/encounter
                                                                .addResponseHeader("X-Docs-Service",
                                                                                "encounter-service"))
                                                .uri("http://encounter-service:8082"))

                                .build();
        }
}
```

### File: ./src/main/java/de/his/gateway/config/PvsGatewayProperties.java
```java
package de.his.gateway.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.NestedConfigurationProperty;
import org.springframework.stereotype.Component;

import java.time.Duration;
import java.util.List;

/**
 * Configuration Properties for HIS API Gateway
 * 
 * Centralizes all gateway-specific configuration in a type-safe manner.
 */
@Component
@ConfigurationProperties(prefix = "his.gateway")
public class PvsGatewayProperties {

    @NestedConfigurationProperty
    private SecurityConfig security = new SecurityConfig();

    @NestedConfigurationProperty
    private ServicesConfig services = new ServicesConfig();

    @NestedConfigurationProperty
    private RateLimitConfig rateLimit = new RateLimitConfig();

    @NestedConfigurationProperty
    private AuditConfig audit = new AuditConfig();

    // Getters and Setters
    public SecurityConfig getSecurity() {
        return security;
    }

    public void setSecurity(SecurityConfig security) {
        this.security = security;
    }

    public ServicesConfig getServices() {
        return services;
    }

    public void setServices(ServicesConfig services) {
        this.services = services;
    }

    public RateLimitConfig getRateLimit() {
        return rateLimit;
    }

    public void setRateLimit(RateLimitConfig rateLimit) {
        this.rateLimit = rateLimit;
    }

    public AuditConfig getAudit() {
        return audit;
    }

    public void setAudit(AuditConfig audit) {
        this.audit = audit;
    }

    /**
     * Security Configuration
     */
    public static class SecurityConfig {
        @NestedConfigurationProperty
        private JwtConfig jwt = new JwtConfig();

        @NestedConfigurationProperty
        private RbacConfig rbac = new RbacConfig();

        public JwtConfig getJwt() {
            return jwt;
        }

        public void setJwt(JwtConfig jwt) {
            this.jwt = jwt;
        }

        public RbacConfig getRbac() {
            return rbac;
        }

        public void setRbac(RbacConfig rbac) {
            this.rbac = rbac;
        }
    }

    /**
     * JWT Configuration
     */
    public static class JwtConfig {
        private boolean enabled = false;
        private String secret = "default-secret-key-change-in-production";
        private long expiration = 86400; // 24 hours in seconds

        public boolean isEnabled() {
            return enabled;
        }

        public void setEnabled(boolean enabled) {
            this.enabled = enabled;
        }

        public String getSecret() {
            return secret;
        }

        public void setSecret(String secret) {
            this.secret = secret;
        }

        public long getExpiration() {
            return expiration;
        }

        public void setExpiration(long expiration) {
            this.expiration = expiration;
        }
    }

    /**
     * RBAC Configuration
     */
    public static class RbacConfig {
        private boolean enabled = false;
        private List<String> adminRoles = List.of("ADMIN", "SYSTEM_ADMIN");
        private List<String> doctorRoles = List.of("DOCTOR", "PHYSICIAN");
        private List<String> nurseRoles = List.of("NURSE", "NURSE_PRACTITIONER");
        private List<String> readonlyRoles = List.of("READONLY", "GUEST");

        public boolean isEnabled() {
            return enabled;
        }

        public void setEnabled(boolean enabled) {
            this.enabled = enabled;
        }

        public List<String> getAdminRoles() {
            return adminRoles;
        }

        public void setAdminRoles(List<String> adminRoles) {
            this.adminRoles = adminRoles;
        }

        public List<String> getDoctorRoles() {
            return doctorRoles;
        }

        public void setDoctorRoles(List<String> doctorRoles) {
            this.doctorRoles = doctorRoles;
        }

        public List<String> getNurseRoles() {
            return nurseRoles;
        }

        public void setNurseRoles(List<String> nurseRoles) {
            this.nurseRoles = nurseRoles;
        }

        public List<String> getReadonlyRoles() {
            return readonlyRoles;
        }

        public void setReadonlyRoles(List<String> readonlyRoles) {
            this.readonlyRoles = readonlyRoles;
        }
    }

    /**
     * Services Configuration
     */
    public static class ServicesConfig {
        @NestedConfigurationProperty
        private ServiceConfig patient = new ServiceConfig("http://patient-service:8081", Duration.ofSeconds(30), 3);

        @NestedConfigurationProperty
        private ServiceConfig encounter = new ServiceConfig("http://encounter-service:8082", Duration.ofSeconds(30), 3);

        public ServiceConfig getPatient() {
            return patient;
        }

        public void setPatient(ServiceConfig patient) {
            this.patient = patient;
        }

        public ServiceConfig getEncounter() {
            return encounter;
        }

        public void setEncounter(ServiceConfig encounter) {
            this.encounter = encounter;
        }
    }

    /**
     * Individual Service Configuration
     */
    public static class ServiceConfig {
        private String url;
        private Duration timeout;
        private int retries;

        public ServiceConfig() {
        }

        public ServiceConfig(String url, Duration timeout, int retries) {
            this.url = url;
            this.timeout = timeout;
            this.retries = retries;
        }

        public String getUrl() {
            return url;
        }

        public void setUrl(String url) {
            this.url = url;
        }

        public Duration getTimeout() {
            return timeout;
        }

        public void setTimeout(Duration timeout) {
            this.timeout = timeout;
        }

        public int getRetries() {
            return retries;
        }

        public void setRetries(int retries) {
            this.retries = retries;
        }
    }

    /**
     * Rate Limiting Configuration
     */
    public static class RateLimitConfig {
        private boolean enabled = false;
        private int defaultRate = 100; // requests per minute
        private int burstCapacity = 200;

        public boolean isEnabled() {
            return enabled;
        }

        public void setEnabled(boolean enabled) {
            this.enabled = enabled;
        }

        public int getDefaultRate() {
            return defaultRate;
        }

        public void setDefaultRate(int defaultRate) {
            this.defaultRate = defaultRate;
        }

        public int getBurstCapacity() {
            return burstCapacity;
        }

        public void setBurstCapacity(int burstCapacity) {
            this.burstCapacity = burstCapacity;
        }
    }

    /**
     * Audit Configuration
     */
    public static class AuditConfig {
        private boolean enabled = true;
        private boolean includeRequestBody = false;
        private boolean includeResponseBody = false;
        private List<String> sensitiveHeaders = List.of("authorization", "x-api-key", "cookie");

        public boolean isEnabled() {
            return enabled;
        }

        public void setEnabled(boolean enabled) {
            this.enabled = enabled;
        }

        public boolean isIncludeRequestBody() {
            return includeRequestBody;
        }

        public void setIncludeRequestBody(boolean includeRequestBody) {
            this.includeRequestBody = includeRequestBody;
        }

        public boolean isIncludeResponseBody() {
            return includeResponseBody;
        }

        public void setIncludeResponseBody(boolean includeResponseBody) {
            this.includeResponseBody = includeResponseBody;
        }

        public List<String> getSensitiveHeaders() {
            return sensitiveHeaders;
        }

        public void setSensitiveHeaders(List<String> sensitiveHeaders) {
            this.sensitiveHeaders = sensitiveHeaders;
        }
    }
}

```

### File: ./src/main/java/de/his/gateway/config/SecurityConfig.java
```java
package de.his.gateway.config;

import de.his.gateway.filter.JwtAuthenticationFilter;
import de.his.gateway.service.JwtService;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
import org.springframework.security.config.web.server.SecurityWebFiltersOrder;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.web.server.SecurityWebFilterChain;
import org.springframework.security.web.server.authentication.HttpStatusServerEntryPoint;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsConfigurationSource;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;

import java.util.Arrays;
import java.util.List;

@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

    private final PvsGatewayProperties gatewayProperties; // ← Geändert

    public SecurityConfig(PvsGatewayProperties gatewayProperties) { // ← Geändert
        this.gatewayProperties = gatewayProperties;
    }

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        return http
                .csrf(csrf -> csrf.disable())
                .httpBasic(httpBasic -> httpBasic.disable())
                .formLogin(formLogin -> formLogin.disable())
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))

                .exceptionHandling(exceptions -> exceptions
                        .authenticationEntryPoint(new HttpStatusServerEntryPoint(HttpStatus.UNAUTHORIZED)))

                .authorizeExchange(exchanges -> {
                    if (gatewayProperties.getSecurity().getJwt().isEnabled()) {
                        exchanges
                                .pathMatchers(HttpMethod.OPTIONS, "/**").permitAll()
                                .pathMatchers("/actuator/health", "/actuator/info").permitAll()
                                .pathMatchers("/swagger-ui/**", "/api-docs/**", "/docs/**").permitAll()
                                .pathMatchers("/auth/**", "/login", "/logout").permitAll()
                                .pathMatchers("/fallback/**").permitAll()
                                .anyExchange().authenticated();
                    } else {
                        exchanges.anyExchange().permitAll();
                    }
                })

                .build();
    }

    @Bean
    @ConditionalOnProperty(name = "his.gateway.security.jwt.enabled", havingValue = "true")
    public JwtAuthenticationFilter jwtAuthenticationFilter(JwtService jwtService) {
        return new JwtAuthenticationFilter(jwtService);
    }

    @Bean
    @ConditionalOnProperty(name = "his.gateway.security.jwt.enabled", havingValue = "false", matchIfMissing = true)
    public JwtAuthenticationFilter noOpJwtFilter() {
        return new JwtAuthenticationFilter(null);
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();

        configuration.setAllowedOriginPatterns(List.of("*"));

        configuration.setAllowedMethods(Arrays.asList(
                "GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));

        configuration.setAllowedHeaders(Arrays.asList(
                "Authorization", "Cache-Control", "Content-Type",
                "X-Requested-With", "Accept", "Origin",
                "X-Session-Token", "X-CSRF-Token"));

        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);

        return source;
    }
}

```

### File: ./src/main/java/de/his/gateway/controller/FallbackController.java
```java
package de.his.gateway.controller;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDateTime;
import java.util.Map;

/**
 * Fallback Controller for Circuit Breaker
 * 
 * Provides graceful degradation when microservices are unavailable.
 * Returns appropriate error responses with helpful information.
 */
@RestController
@RequestMapping("/fallback")
public class FallbackController {

    /**
     * Generic fallback for any service
     */
    @GetMapping("/default")
    public ResponseEntity<Map<String, Object>> defaultFallback() {
        return createFallbackResponse(
                "SERVICE_UNAVAILABLE",
                "The requested service is currently unavailable. Please try again later.",
                "default");
    }

    /**
     * Patient Service fallback
     */
    @GetMapping("/patient-service")
    public ResponseEntity<Map<String, Object>> patientServiceFallback() {
        return createFallbackResponse(
                "PATIENT_SERVICE_UNAVAILABLE",
                "Patient service is currently unavailable. Patient data cannot be accessed at this time.",
                "patient-service");
    }

    /**
     * Encounter Service fallback
     */
    @GetMapping("/encounter-service")
    public ResponseEntity<Map<String, Object>> encounterServiceFallback() {
        return createFallbackResponse(
                "ENCOUNTER_SERVICE_UNAVAILABLE",
                "Encounter service is currently unavailable. Encounter data cannot be accessed at this time.",
                "encounter-service");
    }

    /**
     * Generic service fallback with service name
     */
    @GetMapping("/{serviceName}")
    public ResponseEntity<Map<String, Object>> serviceFallback(@PathVariable String serviceName) {
        return createFallbackResponse(
                "SERVICE_UNAVAILABLE",
                String.format("%s service is currently unavailable. Please try again later.",
                        capitalize(serviceName.replace("-", " "))),
                serviceName);
    }

    /**
     * Health check fallback - indicates partial system availability
     */
    @GetMapping("/health")
    public ResponseEntity<Map<String, Object>> healthFallback() {
        Map<String, Object> response = Map.of(
                "status", "DEGRADED",
                "timestamp", LocalDateTime.now(),
                "message", "Some services are experiencing issues",
                "details", Map.of(
                        "gateway", "UP",
                        "downstream-services", "PARTIAL"));

        return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE).body(response);
    }

    /**
     * Creates a standardized fallback response
     */
    private ResponseEntity<Map<String, Object>> createFallbackResponse(
            String errorCode, String message, String serviceName) {

        Map<String, Object> response = Map.of(
                "error", Map.of(
                        "code", errorCode,
                        "message", message,
                        "service", serviceName,
                        "timestamp", LocalDateTime.now(),
                        "type", "CircuitBreakerFallback"),
                "status", "SERVICE_UNAVAILABLE",
                "recommendations", Map.of(
                        "retry", "Please try again in a few moments",
                        "alternative", "Check service status at /actuator/health",
                        "support", "Contact system administrator if problem persists"));

        return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE).body(response);
    }

    /**
     * Utility method to capitalize strings
     */
    private String capitalize(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        return str.substring(0, 1).toUpperCase() + str.substring(1);
    }
}
```

### File: ./src/main/java/de/his/gateway/filter/JwtAuthenticationFilter.java
```java
package de.his.gateway.filter;

import de.his.gateway.service.JwtService;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilter;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;

import java.util.List;
import java.util.stream.Collectors;

/**
 * JWT Authentication Filter for API Gateway
 * 
 * Intercepts requests and validates JWT tokens in the Authorization header.
 * Sets authentication context for downstream filters.
 */
public class JwtAuthenticationFilter implements WebFilter {

    private final JwtService jwtService;

    public JwtAuthenticationFilter(JwtService jwtService) {
        this.jwtService = jwtService;
    }

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        // Skip JWT processing if service is null (JWT disabled)
        if (jwtService == null) {
            return chain.filter(exchange);
        }

        String path = exchange.getRequest().getPath().value();

        // Skip JWT for public endpoints
        if (isPublicPath(path)) {
            return chain.filter(exchange);
        }

        // Extract Authorization header
        String authHeader = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            // No token provided - let security config handle this
            return chain.filter(exchange);
        }

        try {
            String token = jwtService.extractTokenFromHeader(authHeader);

            if (token != null && jwtService.validateToken(token)) {
                // Extract user information from token
                String username = jwtService.extractUsername(token);
                List<String> roles = jwtService.extractRoles(token);

                // Convert roles to authorities
                List<SimpleGrantedAuthority> authorities = roles.stream()
                        .map(role -> new SimpleGrantedAuthority("ROLE_" + role))
                        .collect(Collectors.toList());

                // Create authentication object
                Authentication authentication = new UsernamePasswordAuthenticationToken(
                        username, null, authorities);

                // Set authentication in security context and continue
                return chain.filter(exchange)
                        .contextWrite(ReactiveSecurityContextHolder.withAuthentication(authentication));
            } else {
                // Invalid token - return unauthorized
                exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
                return exchange.getResponse().setComplete();
            }

        } catch (Exception e) {
            // Token processing error - return unauthorized
            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
            return exchange.getResponse().setComplete();
        }
    }

    /**
     * Check if path is public and doesn't require authentication
     */
    private boolean isPublicPath(String path) {
        return path.startsWith("/actuator/health") ||
                path.startsWith("/actuator/info") ||
                path.startsWith("/swagger-ui") ||
                path.startsWith("/api-docs") ||
                path.startsWith("/docs/") ||
                path.startsWith("/auth/") ||
                path.startsWith("/login") ||
                path.startsWith("/logout") ||
                path.startsWith("/fallback/");
    }
}
```

### File: ./src/main/java/de/his/gateway/service/JwtService.java
```java
package de.his.gateway.service;

import de.his.gateway.config.PvsGatewayProperties; // ← Geändert
import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.stereotype.Service;

import javax.crypto.SecretKey;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

/**
 * JWT Service for Token Generation and Validation
 */
@Service
@ConditionalOnProperty(name = "his.gateway.security.jwt.enabled", havingValue = "true")
public class JwtService {

    private final SecretKey secretKey;
    private final long expirationTime;

    public JwtService(PvsGatewayProperties gatewayProperties) { // ← Geändert
        String secret = gatewayProperties.getSecurity().getJwt().getSecret();
        this.secretKey = Keys.hmacShaKeyFor(secret.getBytes());
        this.expirationTime = gatewayProperties.getSecurity().getJwt().getExpiration();
    }

    public String generateToken(Authentication authentication) {
        String username = authentication.getName();
        List<String> roles = authentication.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.toList());

        Instant now = Instant.now();
        Instant expiration = now.plus(expirationTime, ChronoUnit.SECONDS);

        return Jwts.builder()
                .setSubject(username)
                .claim("roles", roles)
                .claim("iat", Date.from(now))
                .setExpiration(Date.from(expiration))
                .signWith(secretKey, SignatureAlgorithm.HS256)
                .compact();
    }

    public String generateToken(String username, List<String> roles) {
        Instant now = Instant.now();
        Instant expiration = now.plus(expirationTime, ChronoUnit.SECONDS);

        return Jwts.builder()
                .setSubject(username)
                .claim("roles", roles)
                .claim("iat", Date.from(now))
                .setExpiration(Date.from(expiration))
                .signWith(secretKey, SignatureAlgorithm.HS256)
                .compact();
    }

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    @SuppressWarnings("unchecked")
    public List<String> extractRoles(String token) {
        return extractClaim(token, claims -> (List<String>) claims.get("roles"));
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public <T> T extractClaim(String token, ClaimsResolver<T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.resolve(claims);
    }

    private Claims extractAllClaims(String token) {
        try {
            return Jwts.parserBuilder()
                    .setSigningKey(secretKey)
                    .build()
                    .parseClaimsJws(token)
                    .getBody();
        } catch (JwtException e) {
            throw new IllegalArgumentException("Invalid JWT token", e);
        }
    }

    public boolean isTokenExpired(String token) {
        try {
            return extractExpiration(token).before(new Date());
        } catch (Exception e) {
            return true;
        }
    }

    public boolean validateToken(String token, String username) {
        try {
            final String extractedUsername = extractUsername(token);
            return (extractedUsername.equals(username) && !isTokenExpired(token));
        } catch (Exception e) {
            return false;
        }
    }

    public boolean validateToken(String token) {
        try {
            extractAllClaims(token);
            return !isTokenExpired(token);
        } catch (Exception e) {
            return false;
        }
    }

    public String extractTokenFromHeader(String authHeader) {
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            return authHeader.substring(7);
        }
        return null;
    }

    @FunctionalInterface
    public interface ClaimsResolver<T> {
        T resolve(Claims claims);
    }
}

```

### File: ./src/main/resources/application-docker.yml
```yml
server:
  port: 8080

spring:
  application:
    name: his-api-gateway

  cloud:
    gateway:
      # Global CORS Configuration
      globalcors:
        corsConfigurations:
          "[/**]":
            allowedOriginPatterns: "*"
            allowedMethods:
              - GET
              - POST
              - PUT
              - DELETE
              - OPTIONS
              - PATCH
            allowedHeaders:
              - "*"
            allowCredentials: true
            maxAge: 3600

      # Service Discovery (Static for Docker)
      discovery:
        locator:
          enabled: false

      # HTTP Client Configuration
      httpclient:
        connect-timeout: 5000
        response-timeout: 30s
        pool:
          type: elastic
          max-idle-time: 15s
          max-life-time: 60s

  # Redis Configuration (for Rate Limiting)
  data:
    redis:
      host: ${REDIS_HOST:redis}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:}
      timeout: 2000ms
      lettuce:
        pool:
          max-active: 10
          max-idle: 10
          min-idle: 1

# Custom Gateway Configuration
his:
  gateway:
    # Security Configuration
    security:
      jwt:
        enabled: ${JWT_ENABLED:false}
        secret: ${JWT_SECRET:your-secret-key-change-in-production-make-it-longer-than-256-bits}
        expiration: 86400 # 24 hours

      # RBAC Configuration
      rbac:
        enabled: ${RBAC_ENABLED:false}
        admin-roles:
          - ADMIN
          - SYSTEM_ADMIN
        doctor-roles:
          - DOCTOR
          - PHYSICIAN
        nurse-roles:
          - NURSE
          - NURSE_PRACTITIONER
        readonly-roles:
          - READONLY
          - GUEST

    # Service Configuration
    services:
      patient:
        url: ${PATIENT_SERVICE_URL:http://patient-service:8081}
        timeout: 30s
        retries: 3
      encounter:
        url: ${ENCOUNTER_SERVICE_URL:http://encounter-service:8082}
        timeout: 30s
        retries: 3

    # Rate Limiting
    rate-limit:
      enabled: ${RATE_LIMIT_ENABLED:false}
      default-rate: 100 # requests per minute
      burst-capacity: 200

    # Audit Logging
    audit:
      enabled: true
      include-request-body: false
      include-response-body: false
      sensitive-headers:
        - authorization
        - x-api-key
        - cookie

# Circuit Breaker Configuration
resilience4j:
  circuitbreaker:
    instances:
      patient-service-cb:
        registerHealthIndicator: true
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        permittedNumberOfCallsInHalfOpenState: 3
        automaticTransitionFromOpenToHalfOpenEnabled: true
        waitDurationInOpenState: 5s
        failureRateThreshold: 50
        slowCallRateThreshold: 50
        slowCallDurationThreshold: 2s

      encounter-service-cb:
        registerHealthIndicator: true
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        permittedNumberOfCallsInHalfOpenState: 3
        automaticTransitionFromOpenToHalfOpenEnabled: true
        waitDurationInOpenState: 5s
        failureRateThreshold: 50
        slowCallRateThreshold: 50
        slowCallDurationThreshold: 2s

  # Retry Configuration
  retry:
    instances:
      patient-service:
        maxAttempts: 3
        waitDuration: 100ms
        exponentialBackoffMultiplier: 2
        enableExponentialBackoff: true

      encounter-service:
        maxAttempts: 3
        waitDuration: 100ms
        exponentialBackoffMultiplier: 2
        enableExponentialBackoff: true

# Health Check Configuration
management:
  endpoints:
    web:
      exposure:
        include:
          - health
          - info
          - metrics
          - gateway
          - circuitbreakers
          - circuitbreakerevents
          - prometheus
  endpoint:
    health:
      show-details: always
      show-components: always
    gateway:
      enabled: true
  health:
    circuitbreakers:
      enabled: true
  metrics:
    export:
      prometheus:
        enabled: true

# Logging Configuration for Docker
logging:
  level:
    org.springframework.cloud.gateway: INFO
    org.springframework.cloud.gateway.filter: DEBUG
    org.springframework.web.cors: INFO
    org.springframework.security: INFO
    de.his.gateway: DEBUG
    reactor.netty.http.client: INFO
    org.springframework.cloud.loadbalancer: INFO
    resilience4j: INFO
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{traceId:-},%X{spanId:-}] [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{traceId:-},%X{spanId:-}] [%thread] %-5level %logger{36} - %msg%n"
  file:
    name: logs/gateway-service.log
    max-size: 100MB
    max-history: 30
    total-size-cap: 3GB

# API Documentation
springdoc:
  api-docs:
    enabled: true
    path: /api-docs
  swagger-ui:
    enabled: true
    path: /swagger-ui.html
    urls:
      - name: Patient Service
        url: /docs/patient/api-docs
        display-name: "Patient Service API"
      - name: Encounter Service
        url: /docs/encounter/api-docs
        display-name: "Encounter Service API"
      - name: Gateway Service
        url: /api-docs
        display-name: "API Gateway"

```

### File: ./src/main/resources/application.yml
```yml
server:
  port: 8080

spring:
  application:
    name: his-api-gateway

  cloud:
    gateway:
      # Global CORS Configuration
      globalcors:
        corsConfigurations:
          "[/**]":
            allowedOriginPatterns: "*"
            allowedMethods:
              - GET
              - POST
              - PUT
              - DELETE
              - OPTIONS
              - PATCH
            allowedHeaders:
              - "*"
            allowCredentials: true
            maxAge: 3600

      # Circuit Breaker Configuration
      default-filters:
        - name: CircuitBreaker
          args:
            name: default-circuit-breaker
            fallbackUri: forward:/fallback/default
        - name: RequestRateLimiter
          args:
            redis-rate-limiter.replenishRate: 100
            redis-rate-limiter.burstCapacity: 200
            redis-rate-limiter.requestedTokens: 1

      # Service Discovery (Static for Docker)
      discovery:
        locator:
          enabled: false

      # HTTP Client Configuration
      httpclient:
        connect-timeout: 5000
        response-timeout: 30s
        pool:
          type: elastic
          max-idle-time: 15s
          max-life-time: 60s

      # Load Balancer Configuration
      loadbalancer:
        use404: true

  # Security Configuration
  security:
    oauth2:
      resourceserver:
        jwt:
          # JWT Configuration - can be disabled via profile
          enabled: false

  # Redis Configuration (for Rate Limiting)
  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:}
      timeout: 2000ms

# Circuit Breaker Configuration
resilience4j:
  circuitbreaker:
    instances:
      patient-service-cb:
        registerHealthIndicator: true
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        permittedNumberOfCallsInHalfOpenState: 3
        automaticTransitionFromOpenToHalfOpenEnabled: true
        waitDurationInOpenState: 5s
        failureRateThreshold: 50
        eventConsumerBufferSize: 10
        slowCallRateThreshold: 50
        slowCallDurationThreshold: 2s

      encounter-service-cb:
        registerHealthIndicator: true
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        permittedNumberOfCallsInHalfOpenState: 3
        automaticTransitionFromOpenToHalfOpenEnabled: true
        waitDurationInOpenState: 5s
        failureRateThreshold: 50
        eventConsumerBufferSize: 10
        slowCallRateThreshold: 50
        slowCallDurationThreshold: 2s

  # Retry Configuration
  retry:
    instances:
      patient-service:
        maxAttempts: 3
        waitDuration: 100ms
        exponentialBackoffMultiplier: 2
        enableExponentialBackoff: true

      encounter-service:
        maxAttempts: 3
        waitDuration: 100ms
        exponentialBackoffMultiplier: 2
        enableExponentialBackoff: true

# Health Check Configuration
management:
  endpoints:
    web:
      exposure:
        include:
          - health
          - info
          - metrics
          - gateway
          - circuitbreakers
          - circuitbreakerevents
          - prometheus
  endpoint:
    health:
      show-details: always
      show-components: always
      group:
        custom:
          include:
            - ping
            - diskSpace
            - circuitBreakers
    gateway:
      enabled: true
  health:
    circuitbreakers:
      enabled: true
  metrics:
    export:
      prometheus:
        enabled: true
    distribution:
      percentiles-histogram:
        http.server.requests: true

# Logging Configuration
logging:
  level:
    org.springframework.cloud.gateway: DEBUG
    org.springframework.cloud.gateway.filter: DEBUG
    org.springframework.web.cors: DEBUG
    org.springframework.security: INFO
    de.his.gateway: DEBUG
    reactor.netty.http.client: DEBUG
    org.springframework.cloud.loadbalancer: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
  file:
    name: logs/gateway-service.log
    max-size: 100MB
    max-history: 30

# Custom Configuration
his:
  gateway:
    # Security Configuration
    security:
      jwt:
        enabled: ${JWT_ENABLED:false} # Disable JWT by default
        secret: ${JWT_SECRET:default-secret-key-change-in-production}
        expiration: 86400 # 24 hours

      # RBAC Configuration (for future use)
      rbac:
        enabled: ${RBAC_ENABLED:false}
        admin-roles:
          - ADMIN
          - SYSTEM_ADMIN
        doctor-roles:
          - DOCTOR
          - PHYSICIAN
        nurse-roles:
          - NURSE
          - NURSE_PRACTITIONER
        readonly-roles:
          - READONLY
          - GUEST

    # Service Configuration
    services:
      patient:
        url: ${PATIENT_SERVICE_URL:http://patient-service:8081}
        timeout: 30s
        retries: 3
      encounter:
        url: ${ENCOUNTER_SERVICE_URL:http://encounter-service:8082}
        timeout: 30s
        retries: 3

    # Rate Limiting
    rate-limit:
      enabled: ${RATE_LIMIT_ENABLED:false}
      default-rate: 100 # requests per minute
      burst-capacity: 200

    # Audit Logging
    audit:
      enabled: true
      include-request-body: false
      include-response-body: false
      sensitive-headers:
        - authorization
        - x-api-key
        - cookie

# API Documentation
springdoc:
  api-docs:
    enabled: true
    path: /api-docs
  swagger-ui:
    enabled: true
    path: /swagger-ui.html
    urls:
      - name: Patient Service
        url: /docs/patient/api-docs
        display-name: "Patient Service API"
      - name: Encounter Service
        url: /docs/encounter/api-docs
        display-name: "Encounter Service API"
      - name: Gateway Service
        url: /api-docs
        display-name: "API Gateway"

```

### File: ./.mvn/wrapper/maven-wrapper.properties
```properties
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.11/apache-maven-3.9.11-bin.zip

```

### File: ./pom.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.3.0</version>
        <relativePath/>
    </parent>

    <groupId>de.his</groupId>
    <artifactId>his-api-gateway</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <name>HIS API Gateway</name>
    <description>HIS API Gateway Service</description>

    <properties>
        <java.version>21</java.version>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <spring-cloud.version>2023.0.1</spring-cloud.version>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-oauth2-resource-server</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-oauth2-jose</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis-reactive</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-circuitbreaker-reactor-resilience4j</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-loadbalancer</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webflux-ui</artifactId>
            <version>2.5.0</version>
        </dependency>

        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.11.5</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.13.0</version>
                <configuration>
                    <source>21</source>
                    <target>21</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

### File: ./Dockerfile
```dockerfile
# Multi-Stage Docker Build for API Gateway
FROM eclipse-temurin:21-jdk AS build

# Set working directory
WORKDIR /app

# Copy Maven configuration
COPY pom.xml .
COPY .mvn .mvn
COPY mvnw .

# Make mvnw executable (for compatibility)
RUN chmod +x ./mvnw || true

# Download dependencies (cached layer)
RUN ./mvnw dependency:go-offline -B || mvn dependency:go-offline -B

# Copy source code
COPY src src

# Build application
RUN ./mvnw package -DskipTests -B || mvn package -DskipTests -B

# Production Stage - Use standard JRE (not alpine)
FROM eclipse-temurin:21-jre

# Install curl for health checks
RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*

# Create application user for security
RUN groupadd -g 1001 appgroup && \
    useradd -r -u 1001 -g appgroup appuser

# Set working directory
WORKDIR /app

# Copy JAR from build stage
COPY --from=build /app/target/*.jar app.jar

# Change ownership to appuser
RUN chown appuser:appgroup app.jar

# Create logs directory
RUN mkdir -p logs && chown appuser:appgroup logs

# Switch to non-root user
USER appuser

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/actuator/health || exit 1

# Expose port
EXPOSE 8080

# Environment variables
ENV JAVA_OPTS="-Xmx512m -Xms256m -XX:+UseContainerSupport -XX:MaxRAMPercentage=80.0"
ENV SPRING_PROFILES_ACTIVE=docker

# Start application
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]

# Labels for metadata
LABEL maintainer="PVS Team"
LABEL description="API Gateway for Hospital Information System"
LABEL version="1.0.0"
```

