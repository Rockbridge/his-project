# HIS Project Root - Configuration and Infrastructure Files
Generated: So 10 Aug 2025 13:15:05 CEST
Project: Hospital Information System (HIS) - Root Directory
=========================================================

## Root Directory Structure
```
./.vscode/settings.json
./complete-his-test.sh
./create-patients.sh
./debug.sh
./docker-compose-minimal.yml
./docker-compose.dev.yml
./extract-source-files.sh
./his-api-gateway/API Gateway-source.txt
./his-api-gateway/Dockerfile
./his-api-gateway/pom.xml
./his-encounter-service/Dockerfile
./his-encounter-service/Encounter Service-source.txt
./his-encounter-service/pom.xml
./his-patient-service/Dockerfile
./his-patient-service/Patient Service-source.txt
./his-patient-service/pom.xml
./his-project-root-source.txt
./init-scripts/Init Scripts-source.txt
./setup-elk.sh
```

## Available Services
```
drwxr-xr-x  14 mhn  staff    448 10 Aug 08:34 his-api-gateway
drwxr-xr-x@ 18 mhn  staff    576 10 Aug 08:34 his-encounter-service
drwxr-xr-x  16 mhn  staff    512 10 Aug 08:34 his-patient-service
drwxr-xr-x   5 mhn  staff    160 10 Aug 08:39 init-scripts
```

## Root Configuration Files

### File: ./docker-compose-minimal.yml
```yaml
version: "3.8"

services:
  # PostgreSQL Database - Core Infrastructure
  postgres:
    image: postgres:15-alpine
    container_name: his-postgres-minimal
    environment:
      # ✅ Konsistent mit application-docker-minimal.yml
      POSTGRES_DB: his_db
      POSTGRES_USER: his_user
      POSTGRES_PASSWORD: dev_password
      # PostgreSQL Optimierungen
      POSTGRES_INITDB_ARGS: "--encoding=UTF-8 --lc-collate=C --lc-ctype=C"
    volumes:
      - postgres_data_minimal:/var/lib/postgresql/data
      - ./init-scripts:/docker-entrypoint-initdb.d:ro
    ports:
      - "5432:5432"
    networks:
      - his-network-minimal
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U his_user -d his_db"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    restart: unless-stopped

  # Redis - Caching & Rate Limiting
  redis:
    image: redis:7-alpine
    container_name: his-redis-minimal
    command: redis-server --appendonly yes --maxmemory 256mb --maxmemory-policy allkeys-lru
    volumes:
      - redis_data_minimal:/data
    ports:
      - "6379:6379"
    networks:
      - his-network-minimal
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 3
      start_period: 10s
    restart: unless-stopped

  # Patient Service - Port 8081
  patient-service:
    build:
      context: ./his-patient-service
      dockerfile: Dockerfile
    container_name: his-patient-service-minimal
    environment:
      # Database Configuration
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/his_db
      SPRING_DATASOURCE_USERNAME: his_user
      SPRING_DATASOURCE_PASSWORD: dev_password
      # JPA Configuration
      SPRING_JPA_HIBERNATE_DDL_AUTO: update
      SPRING_JPA_SHOW_SQL: true
      SPRING_JPA_PROPERTIES_HIBERNATE_FORMAT_SQL: true
      SPRING_JPA_PROPERTIES_HIBERNATE_DEFAULT_SCHEMA: his_patient
      # Profile Configuration
      SPRING_PROFILES_ACTIVE: docker-minimal
      # Logging Configuration
      LOGGING_LEVEL_DE_HIS_PATIENT: DEBUG
      LOGGING_LEVEL_ORG_HIBERNATE_SQL: DEBUG
      LOGGING_LEVEL_ROOT: INFO
      # Application Configuration
      SERVER_PORT: 8081
      MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE: health,info,metrics
      MANAGEMENT_ENDPOINT_HEALTH_SHOW_DETAILS: always
      # Security Configuration
      SPRING_SECURITY_USER_NAME: admin
      SPRING_SECURITY_USER_PASSWORD: dev-password
      SPRING_SECURITY_USER_ROLES: ADMIN
    ports:
      - "8081:8081"
    networks:
      - his-network-minimal
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
      test:
        [
          "CMD",
          "wget",
          "--no-verbose",
          "--tries=1",
          "--spider",
          "http://localhost:8081/actuator/health",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    restart: unless-stopped
    volumes:
      - ./logs/patient:/app/logs

  # Encounter Service - Port 8082 ✅ KORREKT EINGERÜCKT
  encounter-service:
    build:
      context: ./his-encounter-service
      dockerfile: Dockerfile
    container_name: his-encounter-service-minimal
    environment:
      # Database Configuration - KORRIGIERT
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/his_db
      SPRING_DATASOURCE_USERNAME: his_user
      SPRING_DATASOURCE_PASSWORD: dev_password
      SPRING_DATASOURCE_DRIVER_CLASS_NAME: org.postgresql.Driver
      # JPA Configuration - KORRIGIERT
      SPRING_JPA_HIBERNATE_DDL_AUTO: update
      SPRING_JPA_SHOW_SQL: true
      SPRING_JPA_DATABASE_PLATFORM: org.hibernate.dialect.PostgreSQLDialect
      SPRING_JPA_PROPERTIES_HIBERNATE_DEFAULT_SCHEMA: his_encounter
      SPRING_JPA_PROPERTIES_HIBERNATE_DIALECT: org.hibernate.dialect.PostgreSQLDialect
      # Explizit H2 deaktivieren
      SPRING_H2_CONSOLE_ENABLED: false
      # Security Configuration - NEU
      SPRING_SECURITY_USER_NAME: admin
      SPRING_SECURITY_USER_PASSWORD: dev-password
      SPRING_SECURITY_USER_ROLES: ADMIN
      # Profile Configuration
      SPRING_PROFILES_ACTIVE: docker-minimal
      # Feign Client Configuration
      SERVICES_PATIENT_URL: http://patient-service:8081
      FEIGN_CLIENT_CONFIG_DEFAULT_CONNECT_TIMEOUT: 5000
      FEIGN_CLIENT_CONFIG_DEFAULT_READ_TIMEOUT: 10000
      # Logging Configuration
      LOGGING_LEVEL_DE_HIS_ENCOUNTER: DEBUG
      LOGGING_LEVEL_FEIGN: DEBUG
      LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_CLOUD_OPENFEIGN: DEBUG
      LOGGING_LEVEL_ORG_HIBERNATE_SQL: DEBUG
      LOGGING_LEVEL_ROOT: INFO
      # Application Configuration
      SERVER_PORT: 8082
      MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE: health,info,metrics
      MANAGEMENT_ENDPOINT_HEALTH_SHOW_DETAILS: always
    ports:
      - "8082:8082"
    networks:
      - his-network-minimal
    depends_on:
      postgres:
        condition: service_healthy
      patient-service:
        condition: service_healthy
    healthcheck:
      test:
        [
          "CMD",
          "wget",
          "--no-verbose",
          "--tries=1",
          "--spider",
          "http://localhost:8082/actuator/health",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    restart: unless-stopped
    volumes:
      - ./logs/encounter:/app/logs

  # API Gateway - Port 8080
  api-gateway:
    build:
      context: ./his-api-gateway
      dockerfile: Dockerfile
    container_name: his-api-gateway-minimal
    environment:
      # Patient Service Route
      SPRING_CLOUD_GATEWAY_ROUTES_0_ID: patient-service
      SPRING_CLOUD_GATEWAY_ROUTES_0_URI: http://patient-service:8081
      SPRING_CLOUD_GATEWAY_ROUTES_0_PREDICATES_0: Path=/api/v1/patients/**
      # Encounter Service Route
      SPRING_CLOUD_GATEWAY_ROUTES_1_ID: encounter-service
      SPRING_CLOUD_GATEWAY_ROUTES_1_URI: http://encounter-service:8082
      SPRING_CLOUD_GATEWAY_ROUTES_1_PREDICATES_0: Path=/api/v1/encounters/**
      # Patient Health Route
      SPRING_CLOUD_GATEWAY_ROUTES_2_ID: patient-health
      SPRING_CLOUD_GATEWAY_ROUTES_2_URI: http://patient-service:8081
      SPRING_CLOUD_GATEWAY_ROUTES_2_PREDICATES_0: Path=/services/patient/actuator/**
      SPRING_CLOUD_GATEWAY_ROUTES_2_FILTERS_0: StripPrefix=2
      # Encounter Health Route
      SPRING_CLOUD_GATEWAY_ROUTES_3_ID: encounter-health
      SPRING_CLOUD_GATEWAY_ROUTES_3_URI: http://encounter-service:8082
      SPRING_CLOUD_GATEWAY_ROUTES_3_PREDICATES_0: Path=/services/encounter/actuator/**
      SPRING_CLOUD_GATEWAY_ROUTES_3_FILTERS_0: StripPrefix=2
      # Patient Docs Route
      SPRING_CLOUD_GATEWAY_ROUTES_4_ID: patient-docs
      SPRING_CLOUD_GATEWAY_ROUTES_4_URI: http://patient-service:8081
      SPRING_CLOUD_GATEWAY_ROUTES_4_PREDICATES_0: Path=/docs/patient/**
      SPRING_CLOUD_GATEWAY_ROUTES_4_FILTERS_0: StripPrefix=2
      # Encounter Docs Route
      SPRING_CLOUD_GATEWAY_ROUTES_5_ID: encounter-docs
      SPRING_CLOUD_GATEWAY_ROUTES_5_URI: http://encounter-service:8082
      SPRING_CLOUD_GATEWAY_ROUTES_5_PREDICATES_0: Path=/docs/encounter/**
      SPRING_CLOUD_GATEWAY_ROUTES_5_FILTERS_0: StripPrefix=2
      # Redis Configuration - KORRIGIERT
      SPRING_REDIS_HOST: redis
      SPRING_REDIS_PORT: 6379
      SPRING_REDIS_TIMEOUT: 2000ms
      SPRING_DATA_REDIS_HOST: redis
      SPRING_DATA_REDIS_PORT: 6379
      # Profile Configuration
      SPRING_PROFILES_ACTIVE: docker-minimal
      # Logging Configuration
      LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_CLOUD_GATEWAY: DEBUG
      LOGGING_LEVEL_ROOT: INFO
      # Application Configuration
      SERVER_PORT: 8080
      MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE: health,info,metrics,gateway,circuitbreakers
      MANAGEMENT_ENDPOINT_HEALTH_SHOW_DETAILS: always
    ports:
      - "8080:8080"
    networks:
      - his-network-minimal
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      patient-service:
        condition: service_healthy
      encounter-service:
        condition: service_healthy
    healthcheck:
      test:
        [
          "CMD",
          "wget",
          "--no-verbose",
          "--tries=1",
          "--spider",
          "http://localhost:8080/actuator/health",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 90s
    restart: unless-stopped
    volumes:
      - ./logs/gateway:/app/logs

networks:
  his-network-minimal:
    driver: bridge
    name: his-network-minimal

volumes:
  postgres_data_minimal:
    name: his-postgres-data-minimal
  redis_data_minimal:
    name: his-redis-data-minimal

```

### File: ./docker-compose.dev.yml
```yaml
services:
  # Elasticsearch - Search and Analytics Engine
  elasticsearch:
    image: elasticsearch:8.11.0
    container_name: his-elasticsearch
    environment:
      - node.name=elasticsearch
      - cluster.name=his-cluster
      - discovery.type=single-node
      - bootstrap.memory_lock=true
      - "ES_JAVA_OPTS=-Xms1g -Xmx1g"
      - xpack.security.enabled=false
      - xpack.security.enrollment.enabled=false
      - cluster.routing.allocation.disk.threshold_enabled=false
    ulimits:
      memlock:
        soft: -1
        hard: -1
    volumes:
      - elasticsearch_data:/usr/share/elasticsearch/data
    ports:
      - "9200:9200"
      - "9300:9300"
    networks:
      - elk
    healthcheck:
      test:
        ["CMD-SHELL", "curl -f http://localhost:9200/_cluster/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5

  # Logstash - Log Processing Pipeline
  logstash:
    image: logstash:8.11.0
    container_name: his-logstash
    environment:
      - "LS_JAVA_OPTS=-Xmx512m -Xms512m"
    volumes:
      - ./elk-config/logstash/pipeline:/usr/share/logstash/pipeline:ro
      - ./elk-config/logstash/config/logstash.yml:/usr/share/logstash/config/logstash.yml:ro
      - ./logs:/usr/share/logstash/logs:ro
    ports:
      - "5044:5044"
      - "5001:5001/tcp" # Port 5000 → 5001 (macOS Konflikt vermeiden)
      - "5001:5001/udp" # Port 5000 → 5001 (macOS Konflikt vermeiden)
      - "9600:9600"
    networks:
      - elk
    depends_on:
      elasticsearch:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:9600 || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5

  # Kibana - Data Visualization
  kibana:
    image: kibana:8.11.0
    container_name: his-kibana
    environment:
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
      - ELASTICSEARCH_URL=http://elasticsearch:9200
      - server.host=0.0.0.0
      - server.shutdownTimeout=5s
      - logging.appenders.console.type=console
      - logging.appenders.console.layout.type=json
    volumes:
      - ./elk-config/kibana/kibana.yml:/usr/share/kibana/config/kibana.yml:ro
    ports:
      - "5601:5601"
    networks:
      - elk
    depends_on:
      elasticsearch:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:5601/api/status || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5

  # PostgreSQL Database
  postgres:
    image: postgres:15-alpine
    container_name: his-postgres-elk
    environment:
      POSTGRES_DB: his_db
      POSTGRES_USER: his_user
      POSTGRES_PASSWORD: dev_password
      POSTGRES_INITDB_ARGS: "--auth-host=scram-sha-256"
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-db.sql:/docker-entrypoint-initdb.d/init-db.sql
    networks:
      - his-network
      - elk
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U his_user -d his_db"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis for Rate Limiting and Caching
  redis:
    image: redis:7-alpine
    container_name: his-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - his-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    command: redis-server --appendonly yes

  # API Gateway - Central Entry Point
  api-gateway:
    build:
      context: ./his-api-gateway
      dockerfile: Dockerfile
    container_name: his-api-gateway
    environment:
      SPRING_PROFILES_ACTIVE: docker

      # JWT Configuration (disabled by default)
      JWT_ENABLED: "false"
      JWT_SECRET: "your-secret-key-change-in-production-make-it-longer-than-256-bits"

      # Rate Limiting (disabled by default)
      RATE_LIMIT_ENABLED: "false"
      REDIS_HOST: redis
      REDIS_PORT: 6379

      # Service URLs
      PATIENT_SERVICE_URL: "http://patient-service:8081"
      ENCOUNTER_SERVICE_URL: "http://encounter-service:8082"

      # ELK Integration
      LOGSTASH_HOST: logstash
      LOGSTASH_PORT: 5001 # Updated port
    ports:
      - "8080:8080" # Gateway runs on 8080 (external access)
    volumes:
      - ./logs/gateway:/app/logs
    networks:
      - his-network
      - elk
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      logstash:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 5
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
        labels: "service=api-gateway,environment=development"

  # Patient Service - Now on Port 8081
  patient-service:
    build:
      context: ./his-patient-service
      dockerfile: Dockerfile
    container_name: his-patient-service-elk
    environment:
      SPRING_PROFILES_ACTIVE: docker
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/his_patient
      SPRING_DATASOURCE_USERNAME: his_user
      SPRING_DATASOURCE_PASSWORD: dev_password
      SERVER_PORT: 8081 # Changed from 8080 to 8081

      # ELK Integration
      LOGSTASH_HOST: logstash
      LOGSTASH_PORT: 5001 # Updated port
    ports:
      - "8081:8081" # Direct access to Patient Service
    volumes:
      - ./logs/patient:/app/logs
    networks:
      - his-network
      - elk
    depends_on:
      postgres:
        condition: service_healthy
      logstash:
        condition: service_healthy
    healthcheck:
      test:
        [
          "CMD",
          "wget",
          "--no-verbose",
          "--tries=1",
          "--spider",
          "http://localhost:8081/actuator/health",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
        labels: "service=patient-service,environment=development"

  # Encounter Service - Now on Port 8082
  encounter-service:
    build:
      context: ./his-encounter-service
      dockerfile: Dockerfile
    container_name: his-encounter-service-elk
    environment:
      SPRING_PROFILES_ACTIVE: docker
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/his_encounter
      SPRING_DATASOURCE_USERNAME: his_user
      SPRING_DATASOURCE_PASSWORD: dev_password
      SERVER_PORT: 8082 # Changed from 8081 to 8082
      SERVICES_PATIENT_URL: http://patient-service:8081 # Updated Patient Service URL

      # ELK Integration
      LOGSTASH_HOST: logstash
      LOGSTASH_PORT: 5001 # Updated port
    ports:
      - "8082:8082" # Direct access to Encounter Service
    volumes:
      - ./logs/encounter:/app/logs
    networks:
      - his-network
      - elk
    depends_on:
      postgres:
        condition: service_healthy
      patient-service:
        condition: service_healthy
      logstash:
        condition: service_healthy
    healthcheck:
      test:
        [
          "CMD",
          "wget",
          "--no-verbose",
          "--tries=1",
          "--spider",
          "http://localhost:8082/actuator/health",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
        labels: "service=encounter-service,environment=development"

  # Filebeat - Log Shipper
  filebeat:
    image: elastic/filebeat:8.11.0
    container_name: his-filebeat
    user: root
    environment:
      - ELASTICSEARCH_HOST=elasticsearch:9200
      - LOGSTASH_HOST=logstash:5044
    volumes:
      - ./elk-config/filebeat/filebeat.yml:/usr/share/filebeat/filebeat.yml:ro
      - ./logs:/usr/share/filebeat/logs:ro
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - filebeat_data:/usr/share/filebeat/data
    networks:
      - elk
    depends_on:
      logstash:
        condition: service_healthy
    command: filebeat -e -strict.perms=false

volumes:
  elasticsearch_data:
    driver: local
  postgres_data:
    driver: local
  filebeat_data:
    driver: local
  redis_data:
    driver: local

networks:
  his-network:
    driver: bridge
  elk:
    driver: bridge

```

### File: ./complete-his-test.sh
```bash
#!/bin/bash

echo "🏥 HIS SYSTEM - KOMPLETTER API TEST"
echo "===================================="

# Farben für Output
GREEN='\033[0;32m'
RED='\033[0;31m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

BASE_AUTH="Authorization: Basic $(echo -n 'admin:dev-password' | base64)"

# 1. SYSTEM HEALTH CHECK
echo -e "${BLUE}🔍 1. SYSTEM HEALTH CHECK${NC}"
echo "Checking all services..."

echo -n "API Gateway (8080): "
if curl -s http://localhost:8080/actuator/health | grep -q "UP"; then
    echo -e "${GREEN}✅ UP${NC}"
else
    echo -e "${RED}❌ DOWN${NC}"
fi

echo -n "Patient Service (8081): "
if curl -s http://localhost:8081/actuator/health | grep -q "UP"; then
    echo -e "${GREEN}✅ UP${NC}"
else
    echo -e "${RED}❌ DOWN${NC}"
fi

echo -n "Encounter Service (8082): "
if curl -s http://localhost:8082/actuator/health | grep -q "UP"; then
    echo -e "${GREEN}✅ UP${NC}"
else
    echo -e "${RED}❌ DOWN${NC}"
fi

echo ""

# 2. PATIENT ANLEGEN - VOLLSTÄNDIGER TEST
echo -e "${BLUE}🏥 2. PATIENT ANLEGEN (Alle Pflichtfelder)${NC}"

PATIENT_RESPONSE=$(curl -s -X POST "http://localhost:8081/api/v1/patients" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "$BASE_AUTH" \
  -d '{
    "kvnr": "T123456789",
    "firstName": "Max",
    "lastName": "Mustermann",
    "title": "Dr.",
    "birthDate": "1985-03-15",
    "gender": "MALE",
    "phone": "+49 30 12345678",
    "email": "max.mustermann@example.com",
    "insuranceNumber": "1234567890123",
    "insuranceType": "STATUTORY",
    "insuranceCompanyId": "101575519",
    "insuranceCompanyName": "AOK NORDOST - Die Gesundheitskasse",
    "insuranceStatus": "ACTIVE",
    "consentCommunication": true,
    "consentDataProcessing": true
  }')

if echo "$PATIENT_RESPONSE" | jq -e .id > /dev/null 2>&1; then
    echo -e "${GREEN}✅ Patient erfolgreich angelegt!${NC}"
    echo "$PATIENT_RESPONSE" | jq
    
    # Extrahiere Patient ID
    PATIENT_ID=$(echo "$PATIENT_RESPONSE" | jq -r .id)
    echo -e "${YELLOW}📋 Patient ID: $PATIENT_ID${NC}"
else
    echo -e "${RED}❌ Patient anlegen fehlgeschlagen!${NC}"
    echo "$PATIENT_RESPONSE"
    exit 1
fi

echo ""

# 3. PATIENT ABRUFEN - VALIDIERUNG
echo -e "${BLUE}🔍 3. PATIENT ABRUFEN (Validierung)${NC}"

PATIENT_GET=$(curl -s -X GET "http://localhost:8081/api/v1/patients/$PATIENT_ID" \
  -H "Accept: application/json" \
  -H "$BASE_AUTH")

if echo "$PATIENT_GET" | jq -e .id > /dev/null 2>&1; then
    echo -e "${GREEN}✅ Patient erfolgreich abgerufen!${NC}"
    echo "$PATIENT_GET" | jq
else
    echo -e "${RED}❌ Patient abrufen fehlgeschlagen!${NC}"
    echo "$PATIENT_GET"
fi

echo ""

# 4. ENCOUNTER ANLEGEN - VOLLSTÄNDIGER TEST
echo -e "${BLUE}📋 4. ENCOUNTER ANLEGEN (Alle Pflichtfelder)${NC}"

ENCOUNTER_RESPONSE=$(curl -s -X POST "http://localhost:8082/api/v1/encounters" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "$BASE_AUTH" \
  -d "{
    \"patientId\": \"$PATIENT_ID\",
    \"type\": \"OUTPATIENT\",
    \"status\": \"PLANNED\",
    \"reason\": \"Routineuntersuchung - Jahreschecku p\",
    \"scheduledStart\": \"2025-08-08T10:00:00\",
    \"scheduledEnd\": \"2025-08-08T11:00:00\",
    \"priority\": \"ROUTINE\",
    \"location\": \"Praxis Dr. Mustermann\",
    \"department\": \"Allgemeinmedizin\",
    \"practitioner\": \"Dr. Sarah Schmidt\",
    \"billingContext\": {
      \"insuranceType\": \"STATUTORY\",
      \"billingNumber\": \"12345678\",
      \"costCenter\": \"AMB-001\"
    },
    \"documentation\": [
      {
        \"type\": \"ANAMNESIS\",
        \"content\": \"Patient berichtet über gelegentliche Kopfschmerzen\",
        \"authorId\": \"dr-schmidt\",
        \"timestamp\": \"2025-08-08T10:15:00\"
      }
    ]
  }")

if echo "$ENCOUNTER_RESPONSE" | jq -e .id > /dev/null 2>&1; then
    echo -e "${GREEN}✅ Encounter erfolgreich angelegt!${NC}"
    echo "$ENCOUNTER_RESPONSE" | jq
    
    # Extrahiere Encounter ID
    ENCOUNTER_ID=$(echo "$ENCOUNTER_RESPONSE" | jq -r .id)
    echo -e "${YELLOW}📋 Encounter ID: $ENCOUNTER_ID${NC}"
else
    echo -e "${RED}❌ Encounter anlegen fehlgeschlagen!${NC}"
    echo "$ENCOUNTER_RESPONSE"
fi

echo ""

# 5. PATIENT SUCHE TESTEN
echo -e "${BLUE}🔍 5. PATIENT SUCHE TESTEN${NC}"

SEARCH_RESPONSE=$(curl -s -X GET "http://localhost:8081/api/v1/patients/search?searchTerm=Mustermann&page=0&size=10" \
  -H "Accept: application/json" \
  -H "$BASE_AUTH")

if echo "$SEARCH_RESPONSE" | jq -e .content > /dev/null 2>&1; then
    echo -e "${GREEN}✅ Patient Suche erfolgreich!${NC}"
    FOUND_COUNT=$(echo "$SEARCH_RESPONSE" | jq '.content | length')
    echo -e "${YELLOW}📊 Gefundene Patienten: $FOUND_COUNT${NC}"
    echo "$SEARCH_RESPONSE" | jq '.content[] | {id, fullName, kvnr}'
else
    echo -e "${RED}❌ Patient Suche fehlgeschlagen!${NC}"
    echo "$SEARCH_RESPONSE"
fi

echo ""

# 6. PATIENT ÜBER KVNR ABRUFEN
echo -e "${BLUE}🔍 6. PATIENT ÜBER KVNR ABRUFEN${NC}"

KVNR_RESPONSE=$(curl -s -X GET "http://localhost:8081/api/v1/patients/kvnr/T123456789" \
  -H "Accept: application/json" \
  -H "$BASE_AUTH")

if echo "$KVNR_RESPONSE" | jq -e .id > /dev/null 2>&1; then
    echo -e "${GREEN}✅ Patient über KVNR erfolgreich gefunden!${NC}"
    echo "$KVNR_RESPONSE" | jq '{id, fullName, kvnr, insuranceStatus}'
else
    echo -e "${RED}❌ Patient über KVNR nicht gefunden!${NC}"
    echo "$KVNR_RESPONSE"
fi

echo ""

# 7. API GATEWAY ROUTING TESTEN
echo -e "${BLUE}🌐 7. API GATEWAY ROUTING TESTEN${NC}"

echo "Testing Patient Service via API Gateway..."
GATEWAY_PATIENT=$(curl -s -X GET "http://localhost:8080/api/v1/patients/$PATIENT_ID" \
  -H "Accept: application/json" \
  -H "$BASE_AUTH")

if echo "$GATEWAY_PATIENT" | jq -e .id > /dev/null 2>&1; then
    echo -e "${GREEN}✅ API Gateway → Patient Service routing funktioniert!${NC}"
else
    echo -e "${RED}❌ API Gateway → Patient Service routing fehlgeschlagen!${NC}"
fi

echo "Testing Encounter Service via API Gateway..."
GATEWAY_ENCOUNTER=$(curl -s -X GET "http://localhost:8080/api/v1/encounters/$ENCOUNTER_ID" \
  -H "Accept: application/json" \
  -H "$BASE_AUTH" 2>/dev/null || echo '{"error":"not implemented"}')

if echo "$GATEWAY_ENCOUNTER" | jq -e .id > /dev/null 2>&1; then
    echo -e "${GREEN}✅ API Gateway → Encounter Service routing funktioniert!${NC}"
else
    echo -e "${YELLOW}⚠️ API Gateway → Encounter Service routing nicht konfiguriert oder Endpoint nicht implementiert${NC}"
fi

echo ""

# 8. FEIGN CLIENT TEST (Service-zu-Service Kommunikation)
echo -e "${BLUE}🔗 8. FEIGN CLIENT TEST (Service-zu-Service)${NC}"

if [[ "$ENCOUNTER_RESPONSE" == *"$PATIENT_ID"* ]]; then
    echo -e "${GREEN}✅ Feign Client: Encounter Service kann Patient Service erreichen!${NC}"
    echo -e "${YELLOW}📋 Patient ID wurde erfolgreich im Encounter referenziert${NC}"
else
    echo -e "${RED}❌ Feign Client Problem: Patient Referenz nicht korrekt${NC}"
fi

echo ""

# 9. ZUSAMMENFASSUNG
echo -e "${BLUE}📊 9. TEST ZUSAMMENFASSUNG${NC}"
echo "=========================================="
echo -e "${GREEN}✅ ERFOLGREICH GETESTET:${NC}"
echo "   • Patient Service: CREATE, READ, SEARCH, KVNR-Lookup"
echo "   • Encounter Service: CREATE mit Patient-Referenz"  
echo "   • API Gateway: Routing zu Services"
echo "   • Database: PostgreSQL + Flyway Migrationen"
echo "   • Service Communication: Feign Client"
echo ""
echo -e "${YELLOW}📋 ERSTELLTE DATEN:${NC}"
echo "   • Patient: $PATIENT_ID (KVNR: T123456789)"
echo "   • Encounter: $ENCOUNTER_ID"
echo ""
echo -e "${GREEN}🎉 HIS SYSTEM VOLLSTÄNDIG FUNKTIONSFÄHIG!${NC}"
echo ""
echo -e "${BLUE}🔗 NÜTZLICHE ENDPOINTS:${NC}"
echo "   • Patient Service: http://localhost:8081"
echo "   • Encounter Service: http://localhost:8082"  
echo "   • API Gateway: http://localhost:8080"
echo "   • Swagger UI (Patient): http://localhost:8081/swagger-ui/index.html"
echo "   • Swagger UI (Encounter): http://localhost:8082/swagger-ui/index.html"
```

### File: ./create-patients.sh
```bash
#!/bin/bash
echo "👥 Creating realistic test patients with valid KVNRs..."

# Deutsche Krankenkassen Array
declare -a insurance_companies=(
    "AOK Bayern"
    "Techniker Krankenkasse" 
    "Barmer"
    "DAK-Gesundheit"
    "IKK classic"
    "Debeka"
    "HUK-COBURG"
    "Signal Iduna"
)

# Realistische Namen Arrays
declare -a male_names=("Max" "Alexander" "Thomas" "Michael" "Christian" "Andreas" "Stefan" "Markus")
declare -a female_names=("Anna" "Maria" "Sandra" "Julia" "Petra" "Sabine" "Andrea" "Nicole")
declare -a surnames=("Müller" "Schmidt" "Schneider" "Fischer" "Weber" "Meyer" "Wagner" "Becker")

create_realistic_patient() {
    local index=$1
    local gender=$2
    
    # Name selection based on gender
    if [ "$gender" = "MALE" ]; then
        local first_name=${male_names[$((index % ${#male_names[@]}))]}
        local kvnr_prefix="M"
    else
        local first_name=${female_names[$((index % ${#female_names[@]}))]}
        local kvnr_prefix="A"
    fi
    
    local last_name=${surnames[$((index % ${#surnames[@]}))]}
    local insurance=${insurance_companies[$((index % ${#insurance_companies[@]}))]}
    
    # Generate realistic birth date (20-80 years old)
    local birth_year=$((1945 + RANDOM % 60))
    local birth_month=$(printf "%02d" $((1 + RANDOM % 12)))
    local birth_day=$(printf "%02d" $((1 + RANDOM % 28)))
    local birth_date="${birth_year}-${birth_month}-${birth_day}"
    
    # Generate KVNR with birth data
    local year_suffix=${birth_year: -2}
    local kvnr="${kvnr_prefix}${year_suffix}${birth_month}${birth_day}$(printf "%02d" $index)$(( (index * 7) % 10 ))"
    
    # Insurance type based on company
    local insurance_type="STATUTORY"
    if [[ "$insurance" == "Debeka" || "$insurance" == "HUK-COBURG" || "$insurance" == "Signal Iduna" ]]; then
        insurance_type="PRIVATE"
    fi
    
    echo "Creating: $first_name $last_name ($gender, $birth_date, $kvnr)"
    
    curl -s -X POST http://localhost:8080/api/v1/patients \
        -H "Content-Type: application/json" \
        -H "Authorization: Basic $(echo -n 'admin:dev-password' | base64)" \
        -d "{
            \"firstName\": \"$first_name\",
            \"lastName\": \"$last_name\", 
            \"birthDate\": \"$birth_date\",
            \"gender\": \"$gender\",
            \"kvnr\": \"$kvnr\",
            \"insuranceType\": \"$insurance_type\",
            \"insuranceCompanyName\": \"$insurance\",
            \"phone\": \"+49 $((100 + RANDOM % 900)) $((1000000 + RANDOM % 9000000))\",
            \"email\": \"$(echo $first_name | tr '[:upper:]' '[:lower:]').$(echo $last_name | tr '[:upper:]' '[:lower:]')@example.com\",
            \"consentCommunication\": $([[ $((RANDOM % 2)) -eq 0 ]] && echo true || echo false),
            \"consentDataProcessing\": true
        }" | jq '{id, firstName, lastName, kvnr, insuranceType, insuranceCompanyName}' 2>/dev/null
    
    echo ""
}

# Create 10 realistic patients
for i in {1..10}; do
    if [ $((i % 2)) -eq 0 ]; then
        create_realistic_patient $i "FEMALE"
    else 
        create_realistic_patient $i "MALE"
    fi
    sleep 1  # Rate limiting
done

echo "✅ Realistic test data creation completed!"
```

### File: ./debug.sh
```bash
#!/bin/bash

# ===========================================
# HIS SQL DEBUGGING - AUTH WORKS, NO DATA SAVED
# Authentication erfolgreich, aber keine INSERT statements
# ===========================================

echo "🔍 SQL DEBUGGING - AUTH OK, BUT NO DATA SAVED"
echo "=============================================="

NEW_PASSWORD="b0e91dc2-3090-4f2c-8fd2-98c8c94efc3c"
PATIENT_ID="ec3b64a8-f525-4e59-953d-839eb033398d"

# ===========================================
# 1. PROGRESS CONFIRMATION
# ===========================================

echo "1️⃣ PROGRESS CONFIRMATION"
echo "======================="

echo "✅ AUTHENTICATION: FIXED"
echo "• Keine HTTP 401 mehr"
echo "• Service akzeptiert requests"
echo "• Response kommt zurück (leere paginated result)"
echo ""
echo "❌ VERBLEIBENDES PROBLEM:"
echo "• Encounters werden nicht in PostgreSQL gespeichert"
echo "• Keine SQL INSERT statements in logs"
echo "• Silent failure in service logic"

# ===========================================
# 2. SQL LOGGING ANALYSIS
# ===========================================

echo ""
echo "2️⃣ SQL LOGGING ANALYSIS"
echo "======================"

echo "🔍 CHECK FOR SQL STATEMENTS:"
echo ""

echo "Check for any Hibernate SQL in logs:"
docker-compose -f docker-compose-minimal.yml logs encounter-service | grep -i "Hibernate:" | tail -10

echo ""
echo "Check for INSERT statements:"
docker-compose -f docker-compose-minimal.yml logs encounter-service | grep -i "INSERT" | tail -5

echo ""
echo "Check for any SQL activity:"
docker-compose -f docker-compose-minimal.yml logs encounter-service | grep -i "SQL" | tail -10

# ===========================================
# 3. REAL-TIME REQUEST MONITORING
# ===========================================

echo ""
echo "3️⃣ REAL-TIME REQUEST MONITORING"
echo "=============================="

echo "🧪 CREATE ENCOUNTER WITH LIVE LOG MONITORING:"
echo ""

# Create encounter and monitor logs immediately
echo "Creating encounter with live monitoring..."

curl -X POST "http://localhost:8082/api/v1/encounters" \
  -H "Content-Type: application/json" \
  -H "Authorization: Basic $(echo -n "user:${NEW_PASSWORD}" | base64)" \
  -d "{
    \"patientId\": \"${PATIENT_ID}\",
    \"practitionerId\": \"$(uuidgen)\",
    \"type\": \"EMERGENCY\",
    \"encounterDate\": \"$(date -u +%Y-%m-%dT%H:%M:%S)\",
    \"billingContext\": \"GKV\"
  }" && echo "Request sent!"

echo ""
echo "Checking logs immediately after request:"
docker-compose -f docker-compose-minimal.yml logs encounter-service --tail=20

# ===========================================
# 4. VALIDATION FAILURE TESTING
# ===========================================

echo ""
echo "4️⃣ VALIDATION FAILURE TESTING"
echo "============================="

echo "🧪 TEST @VALID ANNOTATION BEHAVIOR:"
echo ""

# Test with missing required fields (should trigger validation error)
echo "Testing with missing required field (should return 400):"
VALIDATION_RESPONSE=$(curl -s -w "HTTP_CODE:%{http_code}\n" \
  -X POST "http://localhost:8082/api/v1/encounters" \
  -H "Content-Type: application/json" \
  -H "Authorization: Basic $(echo -n "user:${NEW_PASSWORD}" | base64)" \
  -d "{\"patientId\":\"${PATIENT_ID}\"}" 2>/dev/null)

echo "Validation test response:"
echo "$VALIDATION_RESPONSE"

# If validation returns 400, then @Valid works
# If validation returns 200/201, then validation is not working

# ===========================================
# 5. SERVICE METHOD DEBUGGING
# ===========================================

echo ""
echo "5️⃣ SERVICE METHOD DEBUGGING"
echo "=========================="

echo "🔍 CHECK SERVICE LAYER LOGGING:"
echo ""

echo "Check for service method calls:"
docker-compose -f docker-compose-minimal.yml logs encounter-service | grep -i "Creating\|encounter\|service" | tail -10

echo ""
echo "Check for any DEBUG level logs:"
docker-compose -f docker-compose-minimal.yml logs encounter-service | grep "DEBUG" | tail -10

echo ""
echo "Check for any transaction logs:"
docker-compose -f docker-compose-minimal.yml logs encounter-service | grep -i "transaction\|commit\|rollback" | tail -5

# ===========================================
# 6. PATIENT VALIDATION TESTING
# ===========================================

echo ""
echo "6️⃣ PATIENT VALIDATION TESTING"
echo "============================="

echo "🔗 TEST FEIGN CLIENT FUNCTIONALITY:"
echo ""

echo "Test 1: Can encounter service reach patient service?"
docker exec his-encounter-service-minimal wget -q --spider http://patient-service:8081/actuator/health && echo "✅ Patient service reachable" || echo "❌ Patient service NOT reachable"

echo ""
echo "Test 2: Patient exists via direct API?"
PATIENT_EXISTS=$(curl -s "http://localhost:8081/api/v1/patients/${PATIENT_ID}" \
  -H "Authorization: Basic $(echo -n 'admin:dev-password' | base64)" | jq -r '.id' 2>/dev/null)

if [ "$PATIENT_EXISTS" = "$PATIENT_ID" ]; then
    echo "✅ Patient exists: $PATIENT_ID"
else
    echo "❌ Patient NOT found or not accessible"
    echo "Response: $PATIENT_EXISTS"
fi

echo ""
echo "Test 3: Encounter with explicit patient validation:"
curl -X POST "http://localhost:8082/api/v1/encounters/with-patient-validation" \
  -H "Content-Type: application/json" \
  -H "Authorization: Basic $(echo -n "user:${NEW_PASSWORD}" | base64)" \
  -d "{
    \"patientId\": \"${PATIENT_ID}\",
    \"practitionerId\": \"$(uuidgen)\",
    \"type\": \"CONSULTATION\",
    \"encounterDate\": \"$(date -u +%Y-%m-%dT%H:%M:%S)\",
    \"billingContext\": \"GKV\"
  }"

echo ""
echo "Logs after patient validation test:"
docker-compose -f docker-compose-minimal.yml logs encounter-service --tail=10

# ===========================================
# 7. DETAILED ERROR ANALYSIS
# ===========================================

echo ""
echo "7️⃣ DETAILED ERROR ANALYSIS"
echo "=========================="

echo "🔍 COMPREHENSIVE LOG ANALYSIS:"
echo ""

echo "All recent encounter service activity:"
docker-compose -f docker-compose-minimal.yml logs encounter-service --since="5m" | tail -30

echo ""
echo "Any warnings or errors:"
docker-compose -f docker-compose-minimal.yml logs encounter-service | grep -i "warn\|error" | tail -10

echo ""
echo "Any exception traces:"
docker-compose -f docker-compose-minimal.yml logs encounter-service | grep -A 5 -B 5 "Exception" | tail -20

# ===========================================
# 8. MANUAL DEBUGGING COMMANDS
# ===========================================

echo ""
echo "8️⃣ MANUAL DEBUGGING COMMANDS"
echo "=========================="

echo "🚀 RUN THESE COMMANDS TO DEBUG:"
echo ""

echo "# 1. Monitor logs in real-time while making request:"
echo "# Terminal 1:"
echo "docker-compose -f docker-compose-minimal.yml logs encounter-service -f"
echo ""
echo "# Terminal 2:"
echo "curl -X POST 'http://localhost:8082/api/v1/encounters' \\"
echo "  -H 'Content-Type: application/json' \\"
echo "  -H 'Authorization: Basic \$(echo -n \"user:${NEW_PASSWORD}\" | base64)' \\"
echo "  -d '{"
echo "    \"patientId\": \"${PATIENT_ID}\","
echo "    \"practitionerId\": \"'$(uuidgen)'\","
echo "    \"type\": \"CONSULTATION\","
echo "    \"encounterDate\": \"'$(date -u +%Y-%m-%dT%H:%M:%S)'\","
echo "    \"billingContext\": \"GKV\""
echo "  }'"
echo ""

echo "# 2. Check if validation is working:"
echo "curl -s -w 'HTTP_CODE:%{http_code}\\n' \\"
echo "  -X POST 'http://localhost:8082/api/v1/encounters' \\"
echo "  -H 'Content-Type: application/json' \\"
echo "  -H 'Authorization: Basic \$(echo -n \"user:${NEW_PASSWORD}\" | base64)' \\"
echo "  -d '{\"patientId\":\"${PATIENT_ID}\"}'"
echo ""

echo "# 3. Test patient service connectivity:"
echo "docker exec his-encounter-service-minimal curl -s http://patient-service:8081/actuator/health"

# ===========================================
# 9. HYPOTHESIS SUMMARY
# ===========================================

echo ""
echo "9️⃣ HYPOTHESIS SUMMARY"
echo "===================="

echo "🎯 CURRENT HYPOTHESES:"
echo ""
echo "HYPOTHESIS A: VALIDATION SILENT FAILURE"
echo "• @Valid @RequestBody CreateEncounterRequest fails"
echo "• GlobalExceptionHandler returns empty response"
echo "• No service method execution"
echo ""
echo "HYPOTHESIS B: PATIENT VALIDATION FAILURE"
echo "• Feign client fails to reach patient service"
echo "• Service throws exception → transaction rollback"
echo "• Exception swallowed by try-catch"
echo ""
echo "HYPOTHESIS C: TRANSACTION ROLLBACK"
echo "• Service saves encounter successfully"
echo "• Later exception → automatic rollback"
echo "• Response sent before rollback"
echo ""
echo "HYPOTHESIS D: MAPPING PROBLEM"
echo "• Request body not mapping to CreateEncounterRequest"
echo "• Controller method not called"
echo "• No service execution"
echo ""
echo "✅ LOGS WILL REVEAL THE EXACT CAUSE!"

# ===========================================
# 10. NEXT STEPS
# ===========================================

echo ""
echo "🔟 NEXT STEPS"
echo "============="

echo "🎯 DEBUGGING PRIORITY:"
echo ""
echo "1. Monitor logs in real-time during request"
echo "2. Check if controller method is called"
echo "3. Check if service method is executed"
echo "4. Check if SQL statements are generated"
echo "5. Check for any exceptions or rollbacks"
echo ""
echo "🚀 START WITH: Real-time log monitoring while making request"
```

### File: ./extract-source-files.sh
```bash
# In das Projekt-Root-Verzeichnis wechseln (wo his-encounter-service/, his-patient-service/, his-api-gateway/ liegen)
cd his-project  # oder wie auch immer dein Root-Verzeichnis heißt

# Sources Verzeichnis erstellen/leeren
echo "Preparing Sources directory..."
if [ -d "Sources" ]; then
    rm -rf Sources/*
else
    mkdir Sources
fi

# Funktion für Service-Extraktion
extract_service() {
    local service_name=$1
    local service_dir=$2
    local output_file="${service_name}-source.txt"
    
    echo "Extracting ${service_name}..."
    
    # In Service-Verzeichnis wechseln
    cd "$service_dir"
    
    # Output-File erstellen
    echo "# HIS ${service_name} - Complete Source Code Structure" > "$output_file"
    echo "Generated: $(date)" >> "$output_file"
    echo "Project: Hospital Information System (HIS) - ${service_name}" >> "$output_file"
    echo "=========================================================" >> "$output_file"
    echo "" >> "$output_file"
    
    # Verzeichnisstruktur anzeigen (ohne Backups)
    echo "## Directory Structure" >> "$output_file"
    echo "\`\`\`" >> "$output_file"
    find . -type f -name "*.java" -o -name "*.yml" -o -name "*.yaml" -o -name "*.properties" -o -name "*.xml" -o -name "*.sql" -o -name "Dockerfile" -o -name "*.md" | grep -v target/ | grep -v .git/ | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | sort >> "$output_file"
    echo "\`\`\`" >> "$output_file"
    echo "" >> "$output_file"
    
    # Tree-Struktur
    echo "## Tree Structure" >> "$output_file"
    echo "\`\`\`" >> "$output_file"
    if command -v tree >/dev/null 2>&1; then
        tree -I 'target|.git|*.class|*.jar|backup*|*.bak|*.backup|*~' >> "$output_file"
    else
        echo "tree command not available - using find alternative:" >> "$output_file"
        find . -type d | grep -v target/ | grep -v .git/ | grep -v backup | sort | sed 's/[^/]*\//|  /g; s/|  \([^|]\)/+--\1/' >> "$output_file"
    fi
    echo "\`\`\`" >> "$output_file"
    echo "" >> "$output_file"
    
    # Source Code Files
    echo "## Source Code Files" >> "$output_file"
    echo "" >> "$output_file"
    
    # Java Files
    find . -name "*.java" | grep -v target/ | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | sort | while read file; do
        echo "### File: $file" >> "$output_file"
        echo "\`\`\`java" >> "$output_file"
        cat "$file" >> "$output_file"
        echo "" >> "$output_file"
        echo "\`\`\`" >> "$output_file"
        echo "" >> "$output_file"
    done
    
    # Configuration Files
    for ext in yml yaml properties; do
        find . -name "*.$ext" | grep -v target/ | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | sort | while read file; do
            echo "### File: $file" >> "$output_file"
            echo "\`\`\`$ext" >> "$output_file"
            cat "$file" >> "$output_file"
            echo "" >> "$output_file"
            echo "\`\`\`" >> "$output_file"
            echo "" >> "$output_file"
        done
    done
    
    # XML Files
    find . -name "*.xml" | grep -v target/ | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | sort | while read file; do
        echo "### File: $file" >> "$output_file"
        echo "\`\`\`xml" >> "$output_file"
        cat "$file" >> "$output_file"
        echo "" >> "$output_file"
        echo "\`\`\`" >> "$output_file"
        echo "" >> "$output_file"
    done
    
    # SQL Files
    find . -name "*.sql" | grep -v target/ | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | sort | while read file; do
        echo "### File: $file" >> "$output_file"
        echo "\`\`\`sql" >> "$output_file"
        cat "$file" >> "$output_file"
        echo "" >> "$output_file"
        echo "\`\`\`" >> "$output_file"
        echo "" >> "$output_file"
    done
    
    # Dockerfile
    if [ -f "Dockerfile" ] && ! echo "Dockerfile" | grep -q -E "(backup|\.bak|\.backup|~$)"; then
        echo "### File: ./Dockerfile" >> "$output_file"
        echo "\`\`\`dockerfile" >> "$output_file"
        cat Dockerfile >> "$output_file"
        echo "" >> "$output_file"
        echo "\`\`\`" >> "$output_file"
        echo "" >> "$output_file"
    fi
    
    # Markdown Files
    find . -name "*.md" | grep -v target/ | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | sort | while read file; do
        echo "### File: $file" >> "$output_file"
        echo "\`\`\`markdown" >> "$output_file"
        cat "$file" >> "$output_file"
        echo "" >> "$output_file"
        echo "\`\`\`" >> "$output_file"
        echo "" >> "$output_file"
    done
    
    # File in Sources Verzeichnis kopieren
    cp "$output_file" "../Sources/"
    
    # Zurück zum Root-Verzeichnis
    cd ..
    
    echo "${service_name} extraction completed: Sources/${output_file}"
}

# Root Directory Files extrahieren
extract_root_files() {
    echo "Extracting Root Directory files..."
    
    local output_file="his-project-root-source.txt"
    
    # Output-File erstellen
    echo "# HIS Project Root - Configuration and Infrastructure Files" > "$output_file"
    echo "Generated: $(date)" >> "$output_file"
    echo "Project: Hospital Information System (HIS) - Root Directory" >> "$output_file"
    echo "=========================================================" >> "$output_file"
    echo "" >> "$output_file"
    
    # Root Directory Structure
    echo "## Root Directory Structure" >> "$output_file"
    echo "\`\`\`" >> "$output_file"
    find . -maxdepth 2 -type f -name "*.yml" -o -name "*.yaml" -o -name "*.md" -o -name "*.txt" -o -name "*.json" -o -name "*.xml" -o -name "*.properties" -o -name "Dockerfile" -o -name "*.sh" | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | grep -v "/target/" | grep -v "Sources/" | sort >> "$output_file"
    echo "\`\`\`" >> "$output_file"
    echo "" >> "$output_file"
    
    # Services Overview
    echo "## Available Services" >> "$output_file"
    echo "\`\`\`" >> "$output_file"
    ls -la | grep "^d" | grep -E "(his-|init-)" >> "$output_file"
    echo "\`\`\`" >> "$output_file"
    echo "" >> "$output_file"
    
    # Root Configuration Files
    echo "## Root Configuration Files" >> "$output_file"
    echo "" >> "$output_file"
    
    # Docker Compose Files
    for file in docker-compose*.yml docker-compose*.yaml; do
        if [ -f "$file" ] && ! echo "$file" | grep -q -E "(backup|\.bak|\.backup|~$)"; then
            echo "### File: ./$file" >> "$output_file"
            echo "\`\`\`yaml" >> "$output_file"
            cat "$file" >> "$output_file"
            echo "" >> "$output_file"
            echo "\`\`\`" >> "$output_file"
            echo "" >> "$output_file"
        fi
    done
    
    # README Files
    for file in README*.md readme*.md; do
        if [ -f "$file" ] && ! echo "$file" | grep -q -E "(backup|\.bak|\.backup|~$)"; then
            echo "### File: ./$file" >> "$output_file"
            echo "\`\`\`markdown" >> "$output_file"
            cat "$file" >> "$output_file"
            echo "" >> "$output_file"
            echo "\`\`\`" >> "$output_file"
            echo "" >> "$output_file"
        fi
    done
    
    # Other Configuration Files
    for file in *.json *.xml *.properties *.txt; do
        if [ -f "$file" ] && ! echo "$file" | grep -q -E "(backup|\.bak|\.backup|~$)" && ! echo "$file" | grep -q "source\.txt$"; then
            echo "### File: ./$file" >> "$output_file"
            echo "\`\`\`" >> "$output_file"
            cat "$file" >> "$output_file"
            echo "" >> "$output_file"
            echo "\`\`\`" >> "$output_file"
            echo "" >> "$output_file"
        fi
    done
    
    # Shell Scripts
    for file in *.sh; do
        if [ -f "$file" ] && ! echo "$file" | grep -q -E "(backup|\.bak|\.backup|~$)"; then
            echo "### File: ./$file" >> "$output_file"
            echo "\`\`\`bash" >> "$output_file"
            cat "$file" >> "$output_file"
            echo "" >> "$output_file"
            echo "\`\`\`" >> "$output_file"
            echo "" >> "$output_file"
        fi
    done
    
    # File in Sources Verzeichnis kopieren
    cp "$output_file" "Sources/"
    
    echo "Root directory extraction completed: Sources/$output_file"
}

# Hauptausführung
echo "Starting HIS Project Source Code Extraction..."
echo "=============================================="

# Root Files extrahieren
extract_root_files

# Init Scripts als separater Service extrahieren
if [ -d "init-scripts" ]; then
    extract_service "Init Scripts" "init-scripts"
else
    echo "Warning: init-scripts directory not found"
fi

# Services extrahieren (prüfen ob Verzeichnisse existieren)
if [ -d "his-encounter-service" ]; then
    extract_service "Encounter Service" "his-encounter-service"
else
    echo "Warning: his-encounter-service directory not found"
fi

if [ -d "his-patient-service" ]; then
    extract_service "Patient Service" "his-patient-service"
else
    echo "Warning: his-patient-service directory not found"
fi

if [ -d "his-api-gateway" ]; then
    extract_service "API Gateway" "his-api-gateway"
else
    echo "Warning: his-api-gateway directory not found"
fi

# Zusammenfassung erstellen
echo ""
echo "Creating extraction summary..."
summary_file="Sources/00-extraction-summary.txt"
echo "HIS Project Source Code Extraction Summary" > "$summary_file"
echo "Generated: $(date)" >> "$summary_file"
echo "==========================================" >> "$summary_file"
echo "" >> "$summary_file"
echo "Extracted Files:" >> "$summary_file"
ls -la Sources/ >> "$summary_file"
echo "" >> "$summary_file"
echo "File Sizes:" >> "$summary_file"
du -h Sources/* >> "$summary_file"

echo ""
echo "=============================================="
echo "Extraction Summary:"
echo "- All files are now available in: ./Sources/"
echo "- Root Directory: Sources/his-project-root-source.txt"
if [ -d "init-scripts" ]; then
    echo "- Init Scripts: Sources/Init Scripts-source.txt"
fi
if [ -d "his-encounter-service" ]; then
    echo "- Encounter Service: Sources/Encounter Service-source.txt"
fi
if [ -d "his-patient-service" ]; then
    echo "- Patient Service: Sources/Patient Service-source.txt"
fi
if [ -d "his-api-gateway" ]; then
    echo "- API Gateway: Sources/API Gateway-source.txt"
fi
echo "- Summary: Sources/00-extraction-summary.txt"
echo ""
echo "All source code extractions completed and copied to Sources directory!"
```

### File: ./setup-elk.sh
```bash
#!/bin/bash
# setup-elk.sh - ELK Stack Konfiguration erstellen

set -e

echo "🔍 Setting up ELK Stack Configuration..."

# Farben für Output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m'

print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# 1. Verzeichnisse erstellen
print_status "Creating ELK configuration directories..."
mkdir -p elk-config/logstash/config
mkdir -p elk-config/logstash/pipeline
mkdir -p elk-config/kibana
mkdir -p elk-config/filebeat
mkdir -p logs/elk

print_success "Directories created"

# 2. Logstash Konfiguration
print_status "Creating Logstash configuration..."
cat > elk-config/logstash/config/logstash.yml << 'EOF'
http.host: "0.0.0.0"
xpack.monitoring.elasticsearch.hosts: [ "http://elasticsearch:9200" ]
path.config: /usr/share/logstash/pipeline
EOF

# 3. Logstash Pipeline für HIS Services
print_status "Creating Logstash pipeline..."
cat > elk-config/logstash/pipeline/logstash.conf << 'EOF'
input {
  # Filebeat input
  beats {
    port => 5044
  }
  
  # TCP input für direkte Service-Logs
  tcp {
    port => 5001
    codec => json_lines
  }
  
  # UDP input (optional)
  udp {
    port => 5001
    codec => json_lines
  }
}

filter {
  # Service-spezifische Filter
  if [fields][service] {
    mutate {
      add_field => { "service_name" => "%{[fields][service]}" }
    }
  }
  
  # Docker Labels verarbeiten
  if [container][labels][service] {
    mutate {
      add_field => { "service_name" => "%{[container][labels][service]}" }
    }
  }
  
  # Log Level extrahieren
  grok {
    match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{DATA:thread}\] %{LOGLEVEL:level} %{DATA:logger} - %{GREEDYDATA:log_message}" }
    tag_on_failure => ["_grokparsefailure"]
  }
  
  # Timestamp parsen
  date {
    match => [ "timestamp", "yyyy-MM-dd HH:mm:ss.SSS" ]
  }
  
  # Service-spezifische Enrichments
  if [service_name] == "api-gateway" {
    mutate {
      add_field => { "component" => "gateway" }
      add_field => { "system" => "his" }
    }
  }
  
  if [service_name] == "patient-service" {
    mutate {
      add_field => { "component" => "patient" }
      add_field => { "system" => "his" }
    }
  }
  
  if [service_name] == "encounter-service" {
    mutate {
      add_field => { "component" => "encounter" }
      add_field => { "system" => "his" }
    }
  }
}

output {
  # Elasticsearch output
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "his-logs-%{+YYYY.MM.dd}"
    template_name => "his-logs"
    template_pattern => "his-logs-*"
    template => {
      "index_patterns" => ["his-logs-*"]
      "settings" => {
        "number_of_shards" => 1
        "number_of_replicas" => 0
      }
      "mappings" => {
        "properties" => {
          "@timestamp" => { "type" => "date" }
          "service_name" => { "type" => "keyword" }
          "component" => { "type" => "keyword" }
          "level" => { "type" => "keyword" }
          "logger" => { "type" => "keyword" }
          "thread" => { "type" => "keyword" }
          "message" => { "type" => "text" }
          "log_message" => { "type" => "text" }
        }
      }
    }
  }
  
  # Debug output (kann später entfernt werden)
  stdout { 
    codec => rubydebug 
  }
}
EOF

# 4. Kibana Konfiguration
print_status "Creating Kibana configuration..."
cat > elk-config/kibana/kibana.yml << 'EOF'
server.name: kibana
server.host: 0.0.0.0
server.port: 5601
elasticsearch.hosts: [ "http://elasticsearch:9200" ]
monitoring.ui.container.elasticsearch.enabled: true

# Dashboard und Index Pattern Konfiguration
kibana.index: ".elvs-kibana"
logging.appenders:
  console:
    type: console
    layout:
      type: json
EOF

# 5. Filebeat Konfiguration
print_status "Creating Filebeat configuration..."
cat > elk-config/filebeat/filebeat.yml << 'EOF'
filebeat.inputs:
# HIS Application Logs
- type: log
  enabled: true
  paths:
    - /usr/share/filebeat/logs/gateway/*.log
    - /usr/share/filebeat/logs/patient/*.log
    - /usr/share/filebeat/logs/encounter/*.log
  fields:
    logtype: application
    system: his
  fields_under_root: true
  multiline.pattern: '^\d{4}-\d{2}-\d{2}'
  multiline.negate: true
  multiline.match: after

# Docker Container Logs
- type: container
  enabled: true
  paths:
    - '/var/lib/docker/containers/*/*.log'
  processors:
    - add_docker_metadata:
        host: "unix:///var/run/docker.sock"

# Output zu Logstash
output.logstash:
  hosts: ["logstash:5044"]

# Processors
processors:
  - add_host_metadata:
      when.not.contains.tags: forwarded
  - add_docker_metadata: ~
  - add_kubernetes_metadata: ~

# Logging Level
logging.level: info
logging.to_files: true
logging.files:
  path: /var/log/filebeat
  name: filebeat
  keepfiles: 7
  permissions: 0644
EOF

# 6. Elasticsearch Index Template erstellen
print_status "Creating Elasticsearch index template..."
cat > elk-config/elasticsearch-template.json << 'EOF'
{
  "index_patterns": ["his-logs-*"],
  "settings": {
    "number_of_shards": 1,
    "number_of_replicas": 0,
    "index.refresh_interval": "5s"
  },
  "mappings": {
    "properties": {
      "@timestamp": {
        "type": "date"
      },
      "service_name": {
        "type": "keyword"
      },
      "component": {
        "type": "keyword"
      },
      "level": {
        "type": "keyword"
      },
      "logger": {
        "type": "keyword"
      },
      "thread": {
        "type": "keyword"
      },
      "message": {
        "type": "text",
        "analyzer": "standard"
      },
      "log_message": {
        "type": "text",
        "analyzer": "standard"
      },
      "container": {
        "properties": {
          "name": {"type": "keyword"},
          "id": {"type": "keyword"}
        }
      }
    }
  }
}
EOF

# 7. Kibana Dashboard-Konfiguration erstellen
print_status "Creating Kibana dashboard configuration..."
mkdir -p elk-config/kibana/dashboards

cat > elk-config/kibana/dashboards/his-dashboard.json << 'EOF'
{
  "dashboard": {
    "id": "his-overview",
    "title": "HIS System Overview",
    "description": "Hospital Information System - Service Overview",
    "version": 1,
    "timeRestore": true,
    "timeTo": "now",
    "timeFrom": "now-1h"
  }
}
EOF

print_success "ELK configuration files created successfully!"

echo ""
echo "📋 Created Configuration Files:"
echo "  • elk-config/logstash/config/logstash.yml"
echo "  • elk-config/logstash/pipeline/logstash.conf"
echo "  • elk-config/kibana/kibana.yml"
echo "  • elk-config/filebeat/filebeat.yml"
echo "  • elk-config/elasticsearch-template.json"
echo ""
echo "🚀 Next Steps:"
echo "  1. Update docker-compose to use original ELK configuration"
echo "  2. Start ELK services: docker-compose -f docker-compose.dev.yml up elk"
echo "  3. Access Kibana: http://localhost:5601"
echo ""
```

