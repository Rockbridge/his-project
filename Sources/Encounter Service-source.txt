# HIS Encounter Service - Complete Source Code Structure
Generated: So 10 Aug 2025 13:15:05 CEST
Project: Hospital Information System (HIS) - Encounter Service
=========================================================

## Directory Structure
```
./.mvn/wrapper/maven-wrapper.properties
./docker/postgres/init.sql
./Dockerfile
./pom.xml
./src/main/java/de/his/encounter/application/dto/CreateEncounterRequest.java
./src/main/java/de/his/encounter/application/dto/DocumentationResponse.java
./src/main/java/de/his/encounter/application/dto/EncounterResponse.java
./src/main/java/de/his/encounter/application/dto/EncounterSummary.java
./src/main/java/de/his/encounter/application/service/EncounterService.java
./src/main/java/de/his/encounter/config/ApplicationConfig.java
./src/main/java/de/his/encounter/config/SecurityConfig.java
./src/main/java/de/his/encounter/domain/model/BillingContext.java
./src/main/java/de/his/encounter/domain/model/ContentType.java
./src/main/java/de/his/encounter/domain/model/Encounter.java
./src/main/java/de/his/encounter/domain/model/EncounterDocumentation.java
./src/main/java/de/his/encounter/domain/model/EncounterStatus.java
./src/main/java/de/his/encounter/domain/model/EncounterType.java
./src/main/java/de/his/encounter/domain/model/SOAPSection.java
./src/main/java/de/his/encounter/domain/repository/EncounterRepository.java
./src/main/java/de/his/encounter/EncounterServiceApplication.java
./src/main/java/de/his/encounter/infrastructure/client/dto/MinimalPatientDto.java
./src/main/java/de/his/encounter/infrastructure/client/dto/PatientDto.java
./src/main/java/de/his/encounter/infrastructure/client/PatientClient.java
./src/main/java/de/his/encounter/infrastructure/exception/EncounterNotFoundException.java
./src/main/java/de/his/encounter/infrastructure/exception/GlobalExceptionHandler.java
./src/main/java/de/his/encounter/infrastructure/exception/InvalidEncounterStateException.java
./src/main/java/de/his/encounter/infrastructure/exception/PatientNotFoundException.java
./src/main/java/de/his/encounter/infrastructure/service/PatientValidationService.java
./src/main/java/de/his/encounter/presentation/controller/EncounterController.java
./src/main/resources/application-docker-minimal.yml
./src/main/resources/application-docker.yml
./src/main/resources/application.yml
./src/main/resources/db/migration/V1__Create_encounters_table.sql
./src/main/resources/db/migration/V2__Create_encounter_documentation_table.sql
./src/test/java/de/his/encounter/application/service/EncounterServiceTest.java
./src/test/java/de/his/encounter/ControllerDirectTest.java
./src/test/java/de/his/encounter/domain/model/EncounterTest.java
./src/test/java/de/his/encounter/EncounterServiceIntegrationTest.java
./src/test/java/de/his/encounter/HttpIntegrationTest.java
./src/test/java/de/his/encounter/MinimalHttpTest.java
./src/test/java/de/his/encounter/presentation/controller/EncounterControllerTest.java
./src/test/java/de/his/encounter/ServiceDirectTest.java
./src/test/java/de/his/encounter/ServiceIntegrationTest.java
./src/test/java/de/his/encounter/TestDataBuilder.java
./src/test/resources/application-test.yml
```

## Tree Structure
```
.
├── docker
│   └── postgres
│       └── init.sql
├── Dockerfile
├── Encounter Service-source.txt
├── infrastructure
│   ├── client
│   │   └── dto
│   └── service
├── logs
├── Makefile
├── mvnw
├── mvnw.cmd
├── pom.xml
└── src
    ├── main
    │   ├── java
    │   │   └── de
    │   │       └── his
    │   │           └── encounter
    │   │               ├── application
    │   │               │   ├── dto
    │   │               │   │   ├── CreateEncounterRequest.java
    │   │               │   │   ├── DocumentationResponse.java
    │   │               │   │   ├── EncounterResponse.java
    │   │               │   │   └── EncounterSummary.java
    │   │               │   └── service
    │   │               │       └── EncounterService.java
    │   │               ├── config
    │   │               │   ├── ApplicationConfig.java
    │   │               │   └── SecurityConfig.java
    │   │               ├── domain
    │   │               │   ├── model
    │   │               │   │   ├── BillingContext.java
    │   │               │   │   ├── ContentType.java
    │   │               │   │   ├── Encounter.java
    │   │               │   │   ├── EncounterDocumentation.java
    │   │               │   │   ├── EncounterStatus.java
    │   │               │   │   ├── EncounterType.java
    │   │               │   │   └── SOAPSection.java
    │   │               │   └── repository
    │   │               │       └── EncounterRepository.java
    │   │               ├── EncounterServiceApplication.java
    │   │               ├── infrastructure
    │   │               │   ├── client
    │   │               │   │   ├── dto
    │   │               │   │   │   ├── MinimalPatientDto.java
    │   │               │   │   │   └── PatientDto.java
    │   │               │   │   └── PatientClient.java
    │   │               │   ├── exception
    │   │               │   │   ├── EncounterNotFoundException.java
    │   │               │   │   ├── GlobalExceptionHandler.java
    │   │               │   │   ├── InvalidEncounterStateException.java
    │   │               │   │   └── PatientNotFoundException.java
    │   │               │   └── service
    │   │               │       └── PatientValidationService.java
    │   │               └── presentation
    │   │                   └── controller
    │   │                       └── EncounterController.java
    │   └── resources
    │       ├── application-docker-minimal.yml
    │       ├── application-docker.yml
    │       ├── application.yml
    │       └── db
    │           └── migration
    │               ├── V1__Create_encounters_table.sql
    │               └── V2__Create_encounter_documentation_table.sql
    └── test
        ├── java
        │   └── de
        │       └── his
        │           └── encounter
        │               ├── application
        │               │   └── service
        │               │       └── EncounterServiceTest.java
        │               ├── ControllerDirectTest.java
        │               ├── domain
        │               │   └── model
        │               │       └── EncounterTest.java
        │               ├── EncounterServiceIntegrationTest.java
        │               ├── HttpIntegrationTest.java
        │               ├── infrastructure
        │               │   └── exception
        │               ├── MinimalHttpTest.java
        │               ├── presentation
        │               │   └── controller
        │               │       └── EncounterControllerTest.java
        │               ├── ServiceDirectTest.java
        │               ├── ServiceIntegrationTest.java
        │               └── TestDataBuilder.java
        └── resources
            └── application-test.yml

45 directories, 48 files
```

## Source Code Files

### File: ./src/main/java/de/his/encounter/application/dto/CreateEncounterRequest.java
```java
package de.his.encounter.application.dto;

import de.his.encounter.domain.model.BillingContext;
import de.his.encounter.domain.model.EncounterType;
import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotNull;

import java.time.LocalDateTime;
import java.util.UUID;

@Schema(description = "Request to create a new encounter")
public class CreateEncounterRequest {

    @NotNull(message = "Patient ID is required")
    @Schema(description = "ID of the patient", example = "123e4567-e89b-12d3-a456-426614174000")
    private UUID patientId;

    @NotNull(message = "Practitioner ID is required")
    @Schema(description = "ID of the practitioner", example = "987fcdeb-51d3-42a8-b456-123456789abc")
    private UUID practitionerId;

    @NotNull(message = "Encounter type is required")
    @Schema(description = "Type of encounter")
    private EncounterType type;

    @NotNull(message = "Encounter date is required")
    @Schema(description = "Date and time of the encounter", example = "2025-08-01T10:30:00")
    private LocalDateTime encounterDate;

    @Schema(description = "Billing context for the encounter")
    private BillingContext billingContext;

    // Constructors
    public CreateEncounterRequest() {
    }

    public CreateEncounterRequest(UUID patientId, UUID practitionerId, EncounterType type,
            LocalDateTime encounterDate, BillingContext billingContext) {
        this.patientId = patientId;
        this.practitionerId = practitionerId;
        this.type = type;
        this.encounterDate = encounterDate;
        this.billingContext = billingContext;
    }

    // Getters and Setters
    public UUID getPatientId() {
        return patientId;
    }

    public void setPatientId(UUID patientId) {
        this.patientId = patientId;
    }

    public UUID getPractitionerId() {
        return practitionerId;
    }

    public void setPractitionerId(UUID practitionerId) {
        this.practitionerId = practitionerId;
    }

    public EncounterType getType() {
        return type;
    }

    public void setType(EncounterType type) {
        this.type = type;
    }

    public LocalDateTime getEncounterDate() {
        return encounterDate;
    }

    public void setEncounterDate(LocalDateTime encounterDate) {
        this.encounterDate = encounterDate;
    }

    public BillingContext getBillingContext() {
        return billingContext;
    }

    public void setBillingContext(BillingContext billingContext) {
        this.billingContext = billingContext;
    }
}

```

### File: ./src/main/java/de/his/encounter/application/dto/DocumentationResponse.java
```java
package de.his.encounter.application.dto;

import de.his.encounter.domain.model.SOAPSection;
import de.his.encounter.domain.model.ContentType;
import io.swagger.v3.oas.annotations.media.Schema;

import java.time.LocalDateTime;
import java.util.UUID;

@Schema(description = "SOAP documentation entry")
public class DocumentationResponse {

    @Schema(description = "Documentation ID")
    private UUID id;

    @Schema(description = "SOAP section")
    private SOAPSection soapSection;

    @Schema(description = "Content type")
    private ContentType contentType;

    @Schema(description = "Documentation content")
    private String content;

    @Schema(description = "Structured content (JSON)")
    private String structuredContent;

    @Schema(description = "Author ID")
    private UUID authorId;

    @Schema(description = "Creation timestamp")
    private LocalDateTime createdAt;

    // Constructor
    public DocumentationResponse(UUID id, SOAPSection soapSection, ContentType contentType,
            String content, String structuredContent, UUID authorId, LocalDateTime createdAt) {
        this.id = id;
        this.soapSection = soapSection;
        this.contentType = contentType;
        this.content = content;
        this.structuredContent = structuredContent;
        this.authorId = authorId;
        this.createdAt = createdAt;
    }

    // Getters and Setters
    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public SOAPSection getSoapSection() {
        return soapSection;
    }

    public void setSoapSection(SOAPSection soapSection) {
        this.soapSection = soapSection;
    }

    public ContentType getContentType() {
        return contentType;
    }

    public void setContentType(ContentType contentType) {
        this.contentType = contentType;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public String getStructuredContent() {
        return structuredContent;
    }

    public void setStructuredContent(String structuredContent) {
        this.structuredContent = structuredContent;
    }

    public UUID getAuthorId() {
        return authorId;
    }

    public void setAuthorId(UUID authorId) {
        this.authorId = authorId;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }
}
```

### File: ./src/main/java/de/his/encounter/application/dto/EncounterResponse.java
```java
package de.his.encounter.application.dto;

import de.his.encounter.domain.model.BillingContext;
import de.his.encounter.domain.model.EncounterStatus;
import de.his.encounter.domain.model.EncounterType;
import io.swagger.v3.oas.annotations.media.Schema;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Schema(description = "Complete encounter information")
public class EncounterResponse {

    @Schema(description = "Unique encounter identifier")
    private UUID id;

    @Schema(description = "Patient identifier")
    private UUID patientId;

    @Schema(description = "Practitioner identifier")
    private UUID practitionerId;

    @Schema(description = "Type of encounter")
    private EncounterType type;

    @Schema(description = "Date and time of encounter")
    private LocalDateTime encounterDate;

    @Schema(description = "Current status of encounter")
    private EncounterStatus status;

    @Schema(description = "Billing context")
    private BillingContext billingContext;

    @Schema(description = "SOAP documentation entries")
    private List<DocumentationResponse> documentation;

    @Schema(description = "Creation timestamp")
    private LocalDateTime createdAt;

    @Schema(description = "Last update timestamp")
    private LocalDateTime updatedAt;

    // Constructor
    public EncounterResponse(UUID id, UUID patientId, UUID practitionerId, EncounterType type,
            LocalDateTime encounterDate, EncounterStatus status, BillingContext billingContext,
            List<DocumentationResponse> documentation, LocalDateTime createdAt, LocalDateTime updatedAt) {
        this.id = id;
        this.patientId = patientId;
        this.practitionerId = practitionerId;
        this.type = type;
        this.encounterDate = encounterDate;
        this.status = status;
        this.billingContext = billingContext;
        this.documentation = documentation;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
    }

    // Getters and Setters
    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public UUID getPatientId() {
        return patientId;
    }

    public void setPatientId(UUID patientId) {
        this.patientId = patientId;
    }

    public UUID getPractitionerId() {
        return practitionerId;
    }

    public void setPractitionerId(UUID practitionerId) {
        this.practitionerId = practitionerId;
    }

    public EncounterType getType() {
        return type;
    }

    public void setType(EncounterType type) {
        this.type = type;
    }

    public LocalDateTime getEncounterDate() {
        return encounterDate;
    }

    public void setEncounterDate(LocalDateTime encounterDate) {
        this.encounterDate = encounterDate;
    }

    public EncounterStatus getStatus() {
        return status;
    }

    public void setStatus(EncounterStatus status) {
        this.status = status;
    }

    public BillingContext getBillingContext() {
        return billingContext;
    }

    public void setBillingContext(BillingContext billingContext) {
        this.billingContext = billingContext;
    }

    public List<DocumentationResponse> getDocumentation() {
        return documentation;
    }

    public void setDocumentation(List<DocumentationResponse> documentation) {
        this.documentation = documentation;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }
}

```

### File: ./src/main/java/de/his/encounter/application/dto/EncounterSummary.java
```java
package de.his.encounter.application.dto;

import de.his.encounter.domain.model.EncounterStatus;
import de.his.encounter.domain.model.EncounterType;
import io.swagger.v3.oas.annotations.media.Schema;

import java.time.LocalDateTime;
import java.util.UUID;

@Schema(description = "Summary view of encounter for timeline display")
public class EncounterSummary {

    @Schema(description = "Encounter identifier")
    private UUID id;

    @Schema(description = "Type of encounter")
    private EncounterType type;

    @Schema(description = "Date and time of encounter")
    private LocalDateTime encounterDate;

    @Schema(description = "Current status")
    private EncounterStatus status;

    @Schema(description = "Number of documentation entries")
    private Integer documentationCount;

    // Constructor
    public EncounterSummary(UUID id, EncounterType type, LocalDateTime encounterDate,
            EncounterStatus status, Integer documentationCount) {
        this.id = id;
        this.type = type;
        this.encounterDate = encounterDate;
        this.status = status;
        this.documentationCount = documentationCount;
    }

    // Getters and Setters
    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public EncounterType getType() {
        return type;
    }

    public void setType(EncounterType type) {
        this.type = type;
    }

    public LocalDateTime getEncounterDate() {
        return encounterDate;
    }

    public void setEncounterDate(LocalDateTime encounterDate) {
        this.encounterDate = encounterDate;
    }

    public EncounterStatus getStatus() {
        return status;
    }

    public void setStatus(EncounterStatus status) {
        this.status = status;
    }

    public Integer getDocumentationCount() {
        return documentationCount;
    }

    public void setDocumentationCount(Integer documentationCount) {
        this.documentationCount = documentationCount;
    }
}

```

### File: ./src/main/java/de/his/encounter/application/service/EncounterService.java
```java
package de.his.encounter.application.service;

import de.his.encounter.application.dto.CreateEncounterRequest;
import de.his.encounter.application.dto.EncounterResponse;
import de.his.encounter.application.dto.EncounterSummary;
import de.his.encounter.application.dto.DocumentationResponse;
import de.his.encounter.domain.model.Encounter;
import de.his.encounter.domain.model.EncounterDocumentation;
import de.his.encounter.domain.repository.EncounterRepository;
import de.his.encounter.infrastructure.exception.EncounterNotFoundException;
import de.his.encounter.infrastructure.exception.PatientNotFoundException;
import de.his.encounter.infrastructure.service.PatientValidationService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@Transactional
public class EncounterService {

    private static final Logger logger = LoggerFactory.getLogger(EncounterService.class);

    private final EncounterRepository encounterRepository;
    private final PatientValidationService patientValidationService;

    public EncounterService(EncounterRepository encounterRepository,
            PatientValidationService patientValidationService) {
        this.encounterRepository = encounterRepository;
        this.patientValidationService = patientValidationService;
    }

    @Transactional
    public EncounterResponse createEncounter(CreateEncounterRequest request) {
        logger.info("Creating new encounter for patient {}", request.getPatientId());

        Encounter encounter = new Encounter(
                request.getPatientId(),
                request.getPractitionerId(),
                request.getType(),
                request.getEncounterDate(),
                request.getBillingContext());

        encounter = encounterRepository.save(encounter);

        logger.info("Created encounter {} for patient {}",
                encounter.getId(), request.getPatientId());

        return mapToResponse(encounter);
    }

    @Transactional
    public EncounterResponse createEncounterWithPatientValidation(CreateEncounterRequest request) {
        logger.info("Creating encounter with patient validation for patient {}", request.getPatientId());

        // Patient-Validierung über Feign Client durchführen
        try {
            if (!patientValidationService.validatePatientExists(request.getPatientId())) {
                logger.warn("Patient validation failed - patient not found: {}", request.getPatientId());
                throw new PatientNotFoundException("Patient not found: " + request.getPatientId());
            }

            logger.info("Patient validation successful for patient {}", request.getPatientId());

            // Optional: Patient-Details für Logging abrufen
            var patientDetails = patientValidationService.getPatientDetails(request.getPatientId());
            if (patientDetails != null) {
                logger.info("Creating encounter for patient: {} {}",
                        patientDetails.getFirstName(), patientDetails.getLastName());
            }

        } catch (PatientNotFoundException e) {
            logger.error("Patient validation failed: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            logger.error("Error during patient validation for {}: {}", request.getPatientId(), e.getMessage());
            throw new RuntimeException("Patient service temporarily unavailable", e);
        }

        // Encounter normal erstellen nach erfolgreicher Validierung
        return createEncounter(request);
    }

    @Transactional(readOnly = true)
    public EncounterResponse getEncounter(UUID encounterId) {
        Encounter encounter = encounterRepository.findById(encounterId)
                .orElseThrow(() -> new EncounterNotFoundException(encounterId));

        return mapToResponse(encounter);
    }

    @Transactional(readOnly = true)
    public Page<EncounterSummary> getPatientEncounters(UUID patientId, Pageable pageable) {
        return encounterRepository.findByPatientIdOrderByEncounterDateDesc(patientId, pageable)
                .map(this::mapToSummary);
    }

    @Transactional(readOnly = true)
    public Page<EncounterSummary> getPatientEncountersInDateRange(
            UUID patientId, LocalDateTime fromDate, LocalDateTime toDate, Pageable pageable) {

        return encounterRepository.findByPatientIdAndDateRange(
                patientId, fromDate, toDate, pageable)
                .map(this::mapToSummary);
    }

    @Transactional
    public EncounterResponse startEncounter(UUID encounterId) {
        Encounter encounter = getEncounterEntity(encounterId);
        encounter.startEncounter();

        encounter = encounterRepository.save(encounter);
        logger.info("Started encounter {}", encounterId);

        return mapToResponse(encounter);
    }

    @Transactional
    public EncounterResponse completeEncounter(UUID encounterId) {
        Encounter encounter = getEncounterEntity(encounterId);
        encounter.completeEncounter();

        encounter = encounterRepository.save(encounter);
        logger.info("Completed encounter {}", encounterId);

        return mapToResponse(encounter);
    }

    @Transactional
    public EncounterResponse addDocumentation(UUID encounterId,
            EncounterDocumentation documentation) {
        Encounter encounter = getEncounterEntity(encounterId);
        encounter.addDocumentation(documentation);

        encounter = encounterRepository.save(encounter);
        logger.info("Added {} documentation to encounter {}",
                documentation.getSoapSection(), encounterId);

        return mapToResponse(encounter);
    }

    private Encounter getEncounterEntity(UUID encounterId) {
        return encounterRepository.findById(encounterId)
                .orElseThrow(() -> new EncounterNotFoundException(encounterId));
    }

    private EncounterResponse mapToResponse(Encounter encounter) {
        return new EncounterResponse(
                encounter.getId(),
                encounter.getPatientId(),
                encounter.getPractitionerId(),
                encounter.getType(),
                encounter.getEncounterDate(),
                encounter.getStatus(),
                encounter.getBillingContext(),
                encounter.getDocumentation().stream()
                        .map(this::mapDocumentationToDto)
                        .collect(Collectors.toList()),
                encounter.getCreatedAt(),
                encounter.getUpdatedAt());
    }

    private EncounterSummary mapToSummary(Encounter encounter) {
        return new EncounterSummary(
                encounter.getId(),
                encounter.getType(),
                encounter.getEncounterDate(),
                encounter.getStatus(),
                encounter.getDocumentation().size());
    }

    private DocumentationResponse mapDocumentationToDto(EncounterDocumentation doc) {
        return new DocumentationResponse(
                doc.getId(),
                doc.getSoapSection(),
                doc.getContentType(),
                doc.getContent(),
                doc.getStructuredContent(),
                doc.getAuthorId(),
                doc.getCreatedAt());
    }
}
```

### File: ./src/main/java/de/his/encounter/config/ApplicationConfig.java
```java
package de.his.encounter.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

@Configuration
public class ApplicationConfig {

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOriginPatterns(Arrays.asList("*"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/api/**", configuration);
        return source;
    }
}

```

### File: ./src/main/java/de/his/encounter/config/SecurityConfig.java
```java
package de.his.encounter.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.beans.factory.annotation.Value;

/**
 * Security Configuration für den Encounter Service
 * 
 * Konfiguration:
 * - Actuator Health Check: Öffentlich zugänglich
 * - Actuator Management Endpoints: Basic Authentication (ADMIN-Role)
 * - API Endpoints: Öffentlich für Service-zu-Service Kommunikation
 * - Swagger UI: Öffentlich zugänglich für Entwicklung
 * 
 * @author HIS Development Team
 * @version 1.0
 */
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Value("${spring.security.user.name:admin}")
    private String adminUsername;

    @Value("${spring.security.user.password:dev-password}")
    private String adminPassword;

    /**
     * Hauptkonfiguration der Security Filter Chain
     */
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                // CSRF deaktiviert für REST API
                .csrf(csrf -> csrf.disable())

                // Session Management: Stateless für REST API
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS))

                // Authorization Rules
                .authorizeHttpRequests(auth -> auth
                        // Health Check: Öffentlich zugänglich
                        .requestMatchers("/actuator/health", "/actuator/health/**").permitAll()

                        // Andere Actuator Endpoints: ADMIN-Role erforderlich
                        .requestMatchers("/actuator/**").hasRole("ADMIN")

                        // Swagger UI und API Docs: Öffentlich für Development
                        .requestMatchers("/swagger-ui/**", "/v3/api-docs/**", "/swagger-ui.html").permitAll()

                        // API Endpoints: Öffentlich für Service-zu-Service Kommunikation
                        .requestMatchers("/api/**").permitAll()

                        // Static Resources: Öffentlich
                        .requestMatchers("/css/**", "/js/**", "/images/**", "/webjars/**").permitAll()

                        // Alle anderen Requests: Authentifizierung erforderlich
                        .anyRequest().authenticated())

                // Basic Authentication für Actuator Management Endpoints
                .httpBasic(basic -> basic
                        .realmName("Encounter Service Management"));

        return http.build();
    }

    /**
     * Password Encoder - BCrypt für sichere Passwort-Verschlüsselung
     */
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    /**
     * In-Memory User Details Service für Development
     * 
     * Erstellt einen Admin-User für Actuator-Zugriff basierend auf
     * den Environment Variables oder application.yml Konfiguration
     */
    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails admin = User.builder()
                .username(adminUsername)
                .password(passwordEncoder().encode(adminPassword))
                .roles("ADMIN")
                .build();

        return new InMemoryUserDetailsManager(admin);
    }
}
```

### File: ./src/main/java/de/his/encounter/domain/model/BillingContext.java
```java
package de.his.encounter.domain.model;

public enum BillingContext {
    GKV("Gesetzliche Krankenversicherung"),
    PKV("Private Krankenversicherung"),
    SELF_PAY("Selbstzahler"),
    BG("Berufsgenossenschaft");

    private final String displayName;

    BillingContext(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() {
        return displayName;
    }
}

```

### File: ./src/main/java/de/his/encounter/domain/model/ContentType.java
```java
package de.his.encounter.domain.model;

public enum ContentType {
    TEXT("Text"),
    STRUCTURED_DATA("Strukturierte Daten");

    private final String displayName;

    ContentType(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() {
        return displayName;
    }
}

```

### File: ./src/main/java/de/his/encounter/domain/model/Encounter.java
```java
package de.his.encounter.domain.model;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "encounters", indexes = {
        @Index(name = "idx_patient_date", columnList = "patient_id, encounter_date"),
        @Index(name = "idx_encounter_date", columnList = "encounter_date"),
        @Index(name = "idx_status", columnList = "status")
})
public class Encounter {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "encounter_id")
    private UUID id;

    @NotNull
    @Column(name = "patient_id", nullable = false)
    private UUID patientId;

    @NotNull
    @Column(name = "practitioner_id", nullable = false)
    private UUID practitionerId;

    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "encounter_type", nullable = false)
    private EncounterType type;

    @NotNull
    @Column(name = "encounter_date", nullable = false)
    private LocalDateTime encounterDate;

    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private EncounterStatus status;

    @Enumerated(EnumType.STRING)
    @Column(name = "billing_context")
    private BillingContext billingContext;

    @OneToMany(mappedBy = "encounter", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<EncounterDocumentation> documentation = new ArrayList<>();

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @Version
    @Column(name = "version")
    private Long version;

    // Constructors
    public Encounter() {
    }

    public Encounter(UUID patientId, UUID practitionerId, EncounterType type,
            LocalDateTime encounterDate, BillingContext billingContext) {
        this.patientId = patientId;
        this.practitionerId = practitionerId;
        this.type = type;
        this.encounterDate = encounterDate;
        this.billingContext = billingContext;
        this.status = EncounterStatus.PLANNED;
    }

    // Getters and Setters
    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public UUID getPatientId() {
        return patientId;
    }

    public void setPatientId(UUID patientId) {
        this.patientId = patientId;
    }

    public UUID getPractitionerId() {
        return practitionerId;
    }

    public void setPractitionerId(UUID practitionerId) {
        this.practitionerId = practitionerId;
    }

    public EncounterType getType() {
        return type;
    }

    public void setType(EncounterType type) {
        this.type = type;
    }

    public LocalDateTime getEncounterDate() {
        return encounterDate;
    }

    public void setEncounterDate(LocalDateTime encounterDate) {
        this.encounterDate = encounterDate;
    }

    public EncounterStatus getStatus() {
        return status;
    }

    public void setStatus(EncounterStatus status) {
        this.status = status;
    }

    public BillingContext getBillingContext() {
        return billingContext;
    }

    public void setBillingContext(BillingContext billingContext) {
        this.billingContext = billingContext;
    }

    // KORREKTUR: Verwendet EncounterDocumentation statt DocumentationResponse
    public List<EncounterDocumentation> getDocumentation() {
        return documentation;
    }

    public void setDocumentation(List<EncounterDocumentation> documentation) {
        this.documentation = documentation;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    public Long getVersion() {
        return version;
    }

    // Business Methods
    public void addDocumentation(EncounterDocumentation doc) {
        doc.setEncounter(this);
        this.documentation.add(doc);
    }

    public void startEncounter() {
        if (this.status != EncounterStatus.PLANNED) {
            throw new IllegalStateException("Encounter can only be started from PLANNED status");
        }
        this.status = EncounterStatus.IN_PROGRESS;
    }

    public void completeEncounter() {
        if (this.status != EncounterStatus.IN_PROGRESS) {
            throw new IllegalStateException("Encounter can only be completed from IN_PROGRESS status");
        }
        this.status = EncounterStatus.COMPLETED;
    }
}
```

### File: ./src/main/java/de/his/encounter/domain/model/EncounterDocumentation.java
```java
package de.his.encounter.domain.model;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "encounter_documentation", indexes = {
        @Index(name = "idx_encounter_soap", columnList = "encounter_id, soap_section"),
        @Index(name = "idx_author_date", columnList = "author_id, created_at")
})
public class EncounterDocumentation {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "documentation_id")
    private UUID id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "encounter_id", nullable = false)
    private Encounter encounter;

    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "soap_section", nullable = false)
    private SOAPSection soapSection;

    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "content_type", nullable = false)
    private ContentType contentType;

    @Column(name = "content", columnDefinition = "TEXT")
    private String content;

    // JSONB für PostgreSQL, TEXT für H2
    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "structured_content", columnDefinition = "TEXT") // Geändert von "jsonb" zu "TEXT"
    private String structuredContent;

    @NotNull
    @Column(name = "author_id", nullable = false)
    private UUID authorId;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    // Constructors
    public EncounterDocumentation() {
    }

    public EncounterDocumentation(SOAPSection soapSection, ContentType contentType,
            String content, UUID authorId) {
        this.soapSection = soapSection;
        this.contentType = contentType;
        this.content = content;
        this.authorId = authorId;
    }

    // Getters and Setters
    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public Encounter getEncounter() {
        return encounter;
    }

    public void setEncounter(Encounter encounter) {
        this.encounter = encounter;
    }

    public SOAPSection getSoapSection() {
        return soapSection;
    }

    public void setSoapSection(SOAPSection soapSection) {
        this.soapSection = soapSection;
    }

    public ContentType getContentType() {
        return contentType;
    }

    public void setContentType(ContentType contentType) {
        this.contentType = contentType;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public String getStructuredContent() {
        return structuredContent;
    }

    public void setStructuredContent(String structuredContent) {
        this.structuredContent = structuredContent;
    }

    public UUID getAuthorId() {
        return authorId;
    }

    public void setAuthorId(UUID authorId) {
        this.authorId = authorId;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }
}

```

### File: ./src/main/java/de/his/encounter/domain/model/EncounterStatus.java
```java
package de.his.encounter.domain.model;

public enum EncounterStatus {
    PLANNED("Planned"),
    IN_PROGRESS("In Progress"),
    COMPLETED("Completed"),
    CANCELLED("Cancelled"),
    NO_SHOW("No Show"),
    POSTPONED("Postponed");

    private final String description;

    EncounterStatus(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}
```

### File: ./src/main/java/de/his/encounter/domain/model/EncounterType.java
```java
package de.his.encounter.domain.model;

public enum EncounterType {
    INITIAL,
    CONSULTATION,
    EMERGENCY,
    ROUTINE_CHECKUP,
    FOLLOW_UP,
    SURGERY,
    DIAGNOSTIC
}
```

### File: ./src/main/java/de/his/encounter/domain/model/SOAPSection.java
```java
package de.his.encounter.domain.model;

public enum SOAPSection {
    SUBJECTIVE("Subjektiv"),
    OBJECTIVE("Objektiv"),
    ASSESSMENT("Beurteilung"),
    PLAN("Plan");

    private final String displayName;

    SOAPSection(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() {
        return displayName;
    }
}

```

### File: ./src/main/java/de/his/encounter/domain/repository/EncounterRepository.java
```java
package de.his.encounter.domain.repository;

import de.his.encounter.domain.model.Encounter;
import de.his.encounter.domain.model.EncounterStatus;
import de.his.encounter.domain.model.EncounterType;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface EncounterRepository extends JpaRepository<Encounter, UUID> {

        // Timeline-Queries für his
        @Query("SELECT e FROM Encounter e WHERE e.patientId = :patientId " +
                        "ORDER BY e.encounterDate DESC")
        Page<Encounter> findByPatientIdOrderByEncounterDateDesc(
                        @Param("patientId") UUID patientId, Pageable pageable);

        @Query("SELECT e FROM Encounter e WHERE e.patientId = :patientId " +
                        "AND e.encounterDate BETWEEN :fromDate AND :toDate " +
                        "ORDER BY e.encounterDate DESC")
        Page<Encounter> findByPatientIdAndDateRange(
                        @Param("patientId") UUID patientId,
                        @Param("fromDate") LocalDateTime fromDate,
                        @Param("toDate") LocalDateTime toDate,
                        Pageable pageable);

        // Status-basierte Queries
        List<Encounter> findByStatusAndEncounterDateBefore(
                        EncounterStatus status, LocalDateTime date);

        @Query("SELECT e FROM Encounter e WHERE e.practitionerId = :practitionerId " +
                        "AND e.status = :status ORDER BY e.encounterDate ASC")
        List<Encounter> findByPractitionerAndStatus(
                        @Param("practitionerId") UUID practitionerId,
                        @Param("status") EncounterStatus status);

        // Aggregation Queries für Statistiken
        @Query("SELECT COUNT(e) FROM Encounter e WHERE e.patientId = :patientId")
        Long countByPatientId(@Param("patientId") UUID patientId);

        @Query("SELECT e.type, COUNT(e) FROM Encounter e WHERE e.patientId = :patientId " +
                        "GROUP BY e.type")
        List<Object[]> countByPatientIdGroupByType(@Param("patientId") UUID patientId);

        // Letzte Encounters
        @Query("SELECT e FROM Encounter e WHERE e.patientId = :patientId " +
                        "AND e.status = 'COMPLETED' ORDER BY e.encounterDate DESC")
        Optional<Encounter> findLastCompletedEncounter(@Param("patientId") UUID patientId);
}
```

### File: ./src/main/java/de/his/encounter/EncounterServiceApplication.java
```java
package de.his.encounter;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
public class EncounterServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(EncounterServiceApplication.class, args);
    }
}
```

### File: ./src/main/java/de/his/encounter/infrastructure/client/dto/MinimalPatientDto.java
```java
package de.his.encounter.infrastructure.client.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.UUID;

@JsonIgnoreProperties(ignoreUnknown = true)
public class MinimalPatientDto {

    private UUID id;
    private String firstName;
    private String lastName;
    private String kvnr;

    // Default constructor for Jackson
    public MinimalPatientDto() {
    }

    // Getters and Setters
    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getKvnr() {
        return kvnr;
    }

    public void setKvnr(String kvnr) {
        this.kvnr = kvnr;
    }

    @Override
    public String toString() {
        return "MinimalPatientDto{" +
                "id=" + id +
                ", firstName='" + firstName + '\'' +
                ", lastName='" + lastName + '\'' +
                ", kvnr='" + kvnr + '\'' +
                '}';
    }
}
```

### File: ./src/main/java/de/his/encounter/infrastructure/client/dto/PatientDto.java
```java
package de.his.encounter.infrastructure.client.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.UUID;

@JsonIgnoreProperties(ignoreUnknown = true)
public class PatientDto {

    private UUID id;
    private String firstName;
    private String lastName;
    private String title;

    @JsonFormat(pattern = "yyyy-MM-dd")
    private LocalDate birthDate;

    private String gender;
    private String kvnr;
    private String insuranceNumber;
    private String insuranceStatus;
    private String insuranceType;
    private String insuranceCompanyId;
    private String insuranceCompanyName;
    private String phone;
    private String email;
    private Boolean consentCommunication;
    private Boolean consentDataProcessing;

    // Flexibles DateTime-Format - nur ein Pattern
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSSSS")
    private LocalDateTime createdAt;

    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSSSS")
    private LocalDateTime updatedAt;

    // Zusätzliches Feld vom Patient Service
    private String fullName;

    // Default constructor for Jackson
    public PatientDto() {
    }

    // Getters and Setters
    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public LocalDate getBirthDate() {
        return birthDate;
    }

    public void setBirthDate(LocalDate birthDate) {
        this.birthDate = birthDate;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public String getKvnr() {
        return kvnr;
    }

    public void setKvnr(String kvnr) {
        this.kvnr = kvnr;
    }

    public String getInsuranceNumber() {
        return insuranceNumber;
    }

    public void setInsuranceNumber(String insuranceNumber) {
        this.insuranceNumber = insuranceNumber;
    }

    public String getInsuranceStatus() {
        return insuranceStatus;
    }

    public void setInsuranceStatus(String insuranceStatus) {
        this.insuranceStatus = insuranceStatus;
    }

    public String getInsuranceType() {
        return insuranceType;
    }

    public void setInsuranceType(String insuranceType) {
        this.insuranceType = insuranceType;
    }

    public String getInsuranceCompanyId() {
        return insuranceCompanyId;
    }

    public void setInsuranceCompanyId(String insuranceCompanyId) {
        this.insuranceCompanyId = insuranceCompanyId;
    }

    public String getInsuranceCompanyName() {
        return insuranceCompanyName;
    }

    public void setInsuranceCompanyName(String insuranceCompanyName) {
        this.insuranceCompanyName = insuranceCompanyName;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public Boolean getConsentCommunication() {
        return consentCommunication;
    }

    public void setConsentCommunication(Boolean consentCommunication) {
        this.consentCommunication = consentCommunication;
    }

    public Boolean getConsentDataProcessing() {
        return consentDataProcessing;
    }

    public void setConsentDataProcessing(Boolean consentDataProcessing) {
        this.consentDataProcessing = consentDataProcessing;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }

    public String getFullName() {
        return fullName;
    }

    public void setFullName(String fullName) {
        this.fullName = fullName;
    }

    @Override
    public String toString() {
        return "PatientDto{" +
                "id=" + id +
                ", firstName='" + firstName + '\'' +
                ", lastName='" + lastName + '\'' +
                ", kvnr='" + kvnr + '\'' +
                '}';
    }
}
```

### File: ./src/main/java/de/his/encounter/infrastructure/client/PatientClient.java
```java
package de.his.encounter.infrastructure.client;

import de.his.encounter.infrastructure.client.dto.PatientDto;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

import java.util.UUID;

@FeignClient(name = "patient-service", url = "${services.patient.url:http://patient-service:8080}")
public interface PatientClient {

    @GetMapping("/api/v1/patients/{patientId}")
    PatientDto getPatient(@PathVariable UUID patientId);

    @GetMapping("/api/v1/patients/kvnr/{kvnr}")
    PatientDto getPatientByKvnr(@PathVariable String kvnr);
}
```

### File: ./src/main/java/de/his/encounter/infrastructure/exception/EncounterNotFoundException.java
```java
package de.his.encounter.infrastructure.exception;

import java.util.UUID;

public class EncounterNotFoundException extends RuntimeException {

    public EncounterNotFoundException(UUID encounterId) {
        super(String.format("Encounter with ID %s not found", encounterId));
    }
}

```

### File: ./src/main/java/de/his/encounter/infrastructure/exception/GlobalExceptionHandler.java
```java
package de.his.encounter.infrastructure.exception;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.servlet.resource.NoResourceFoundException;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * Global Exception Handler für den Encounter Service
 * 
 * WICHTIG: Behandelt nur application-spezifische Exceptions!
 * Spring Framework Exceptions werden bewusst NICHT abgefangen,
 * damit sie ihre korrekten HTTP-Status-Codes behalten.
 * 
 * @author HIS Development Team
 * @version 2.0
 */
@RestControllerAdvice
public class GlobalExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    // =========================================================================
    // APPLICATION-SPEZIFISCHE EXCEPTIONS
    // =========================================================================

    @ExceptionHandler(EncounterNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleEncounterNotFound(EncounterNotFoundException ex) {
        logger.warn("Encounter not found: {}", ex.getMessage());

        ErrorResponse error = new ErrorResponse(
                "ENCOUNTER_NOT_FOUND",
                ex.getMessage(),
                LocalDateTime.now());

        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(PatientNotFoundException.class)
    public ResponseEntity<ErrorResponse> handlePatientNotFound(PatientNotFoundException ex) {
        logger.warn("Patient not found: {}", ex.getMessage());

        ErrorResponse error = new ErrorResponse(
                "PATIENT_NOT_FOUND",
                ex.getMessage(),
                LocalDateTime.now());

        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(InvalidEncounterStateException.class)
    public ResponseEntity<ErrorResponse> handleInvalidEncounterState(InvalidEncounterStateException ex) {
        logger.warn("Invalid encounter state: {}", ex.getMessage());

        ErrorResponse error = new ErrorResponse(
                "INVALID_ENCOUNTER_STATE",
                ex.getMessage(),
                LocalDateTime.now());

        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }

    // =========================================================================
    // VALIDATION EXCEPTIONS
    // =========================================================================

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationErrors(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });

        ErrorResponse error = new ErrorResponse(
                "VALIDATION_ERROR",
                "Validation failed for request",
                LocalDateTime.now(),
                errors);

        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }

    // =========================================================================
    // FEIGN CLIENT EXCEPTIONS (Patient Service Communication)
    // =========================================================================

    @ExceptionHandler(RuntimeException.class)
    public ResponseEntity<ErrorResponse> handleRuntimeException(RuntimeException ex) {
        // Spezifische Behandlung für Patient Service Unavailable
        if (ex.getMessage() != null && ex.getMessage().contains("Patient service temporarily unavailable")) {
            logger.error("Patient service unavailable: {}", ex.getMessage());

            ErrorResponse error = new ErrorResponse(
                    "PATIENT_SERVICE_UNAVAILABLE",
                    ex.getMessage(),
                    LocalDateTime.now());

            return new ResponseEntity<>(error, HttpStatus.SERVICE_UNAVAILABLE);
        }

        // Andere business-logic RuntimeExceptions
        logger.error("Runtime exception occurred: {}", ex.getMessage(), ex);

        ErrorResponse error = new ErrorResponse(
                "SERVICE_ERROR",
                ex.getMessage(),
                LocalDateTime.now());

        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    // =========================================================================
    // SPRING FRAMEWORK EXCEPTIONS - EXPLICIT HANDLING
    // =========================================================================

    /**
     * Behandelt 404-Fehler für nicht gefundene Ressourcen explizit
     * (z.B. Actuator Endpoints, die als Static Resources behandelt werden)
     */
    @ExceptionHandler(NoResourceFoundException.class)
    public ResponseEntity<ErrorResponse> handleNoResourceFound(NoResourceFoundException ex) {
        logger.debug("Resource not found: {}", ex.getMessage());

        ErrorResponse error = new ErrorResponse(
                "RESOURCE_NOT_FOUND",
                "The requested resource was not found",
                LocalDateTime.now());

        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }

    /**
     * Behandelt HTTP Method Not Allowed explizit
     * (z.B. GET auf POST-only Endpoints)
     */
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public ResponseEntity<ErrorResponse> handleMethodNotSupported(HttpRequestMethodNotSupportedException ex) {
        logger.debug("HTTP method not supported: {}", ex.getMessage());

        ErrorResponse error = new ErrorResponse(
                "METHOD_NOT_ALLOWED",
                String.format("HTTP method '%s' is not supported for this endpoint. Supported methods: %s",
                        ex.getMethod(), ex.getSupportedMethods()),
                LocalDateTime.now());

        return new ResponseEntity<>(error, HttpStatus.METHOD_NOT_ALLOWED);
    }

    // =========================================================================
    // FALLBACK - NUR FÜR ECHTE UNBEKANNTE EXCEPTIONS
    // =========================================================================

    /**
     * FALLBACK: Nur für echte unbekannte Exceptions
     * 
     * WICHTIG: Diese Methode sollte nur noch selten aufgerufen werden,
     * da wir die häufigsten Spring Framework Exceptions explizit behandeln.
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericError(Exception ex) {
        // Log nur echte unbekannte Exceptions als ERROR
        logger.error("Unexpected error occurred: {}", ex.getClass().getSimpleName(), ex);

        ErrorResponse error = new ErrorResponse(
                "INTERNAL_SERVER_ERROR",
                "An unexpected error occurred",
                LocalDateTime.now());

        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    // =========================================================================
    // ERROR RESPONSE DTO
    // =========================================================================

    public static class ErrorResponse {
        private String code;
        private String message;
        private LocalDateTime timestamp;
        private Map<String, String> details;

        public ErrorResponse(String code, String message, LocalDateTime timestamp) {
            this.code = code;
            this.message = message;
            this.timestamp = timestamp;
        }

        public ErrorResponse(String code, String message, LocalDateTime timestamp, Map<String, String> details) {
            this.code = code;
            this.message = message;
            this.timestamp = timestamp;
            this.details = details;
        }

        // Getters and Setters
        public String getCode() {
            return code;
        }

        public void setCode(String code) {
            this.code = code;
        }

        public String getMessage() {
            return message;
        }

        public void setMessage(String message) {
            this.message = message;
        }

        public LocalDateTime getTimestamp() {
            return timestamp;
        }

        public void setTimestamp(LocalDateTime timestamp) {
            this.timestamp = timestamp;
        }

        public Map<String, String> getDetails() {
            return details;
        }

        public void setDetails(Map<String, String> details) {
            this.details = details;
        }
    }
}
```

### File: ./src/main/java/de/his/encounter/infrastructure/exception/InvalidEncounterStateException.java
```java
package de.his.encounter.infrastructure.exception;

public class InvalidEncounterStateException extends RuntimeException {

    public InvalidEncounterStateException(String message) {
        super(message);
    }
}

```

### File: ./src/main/java/de/his/encounter/infrastructure/exception/PatientNotFoundException.java
```java
package de.his.encounter.infrastructure.exception;

public class PatientNotFoundException extends RuntimeException {

    public PatientNotFoundException(String message) {
        super(message);
    }

    public PatientNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

### File: ./src/main/java/de/his/encounter/infrastructure/service/PatientValidationService.java
```java
package de.his.encounter.infrastructure.service;

import de.his.encounter.infrastructure.client.PatientClient;
import de.his.encounter.infrastructure.client.dto.PatientDto;
import feign.FeignException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.UUID;

@Service
public class PatientValidationService {

    private static final Logger logger = LoggerFactory.getLogger(PatientValidationService.class);

    private final PatientClient patientClient;

    public PatientValidationService(PatientClient patientClient) {
        this.patientClient = patientClient;
    }

    public boolean validatePatientExists(UUID patientId) {
        try {
            logger.info("Validating patient exists for ID: {}", patientId);
            PatientDto patient = patientClient.getPatient(patientId);
            logger.info("Patient validation successful for ID: {}", patientId);
            return patient != null;
        } catch (FeignException.NotFound e) {
            logger.warn("Patient not found for ID: {} - HTTP Status: {}", patientId, e.status());
            return false;
        } catch (FeignException e) {
            logger.error("Feign error validating patient with ID {}: HTTP Status: {}, Message: {}",
                    patientId, e.status(), e.getMessage());
            throw new RuntimeException("Patient service temporarily unavailable: " + e.getMessage(), e);
        } catch (Exception e) {
            logger.error("Unexpected error validating patient with ID {}: {}", patientId, e.getMessage(), e);
            throw new RuntimeException("Patient validation failed: " + e.getMessage(), e);
        }
    }

    public PatientDto getPatientDetails(UUID patientId) {
        try {
            return patientClient.getPatient(patientId);
        } catch (FeignException.NotFound e) {
            logger.warn("Patient not found for ID: {}", patientId);
            return null;
        } catch (FeignException e) {
            logger.error("Error retrieving patient with ID {}: {}", patientId, e.getMessage());
            throw new RuntimeException("Patient service temporarily unavailable", e);
        }
    }
}
```

### File: ./src/main/java/de/his/encounter/presentation/controller/EncounterController.java
```java
package de.his.encounter.presentation.controller;

import de.his.encounter.application.dto.CreateEncounterRequest;
import de.his.encounter.application.dto.EncounterResponse;
import de.his.encounter.application.dto.EncounterSummary;
import de.his.encounter.application.service.EncounterService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.UUID;

@RestController
@RequestMapping("/api/v1/encounters")
@Tag(name = "Encounters", description = "Encounter Management API")
public class EncounterController {

    private final EncounterService encounterService;

    public EncounterController(EncounterService encounterService) {
        this.encounterService = encounterService;
    }

    @PostMapping
    @Operation(summary = "Create new encounter", description = "Creates a new encounter for a patient")
    public ResponseEntity<EncounterResponse> createEncounter(
            @Valid @RequestBody CreateEncounterRequest request) {

        EncounterResponse response = encounterService.createEncounter(request);
        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }

    @PostMapping("/with-patient-validation")
    @Operation(summary = "Create encounter with patient validation", description = "Creates a new encounter with patient service validation")
    public ResponseEntity<EncounterResponse> createEncounterWithPatientValidation(
            @Valid @RequestBody CreateEncounterRequest request) {

        EncounterResponse response = encounterService.createEncounterWithPatientValidation(request);
        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }

    @GetMapping("/{encounterId}")
    @Operation(summary = "Get encounter details", description = "Retrieves detailed encounter information")
    public ResponseEntity<EncounterResponse> getEncounter(
            @Parameter(description = "Encounter ID") @PathVariable UUID encounterId) {

        EncounterResponse response = encounterService.getEncounter(encounterId);
        return ResponseEntity.ok(response);
    }

    @GetMapping("/patient/{patientId}")
    @Operation(summary = "Get patient encounters", description = "Retrieves encounters for a specific patient")
    public ResponseEntity<Page<EncounterSummary>> getPatientEncounters(
            @Parameter(description = "Patient ID") @PathVariable UUID patientId,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(required = false) LocalDateTime fromDate,
            @RequestParam(required = false) LocalDateTime toDate) {

        Pageable pageable = PageRequest.of(page, size);

        Page<EncounterSummary> encounters;
        if (fromDate != null && toDate != null) {
            encounters = encounterService.getPatientEncountersInDateRange(
                    patientId, fromDate, toDate, pageable);
        } else {
            encounters = encounterService.getPatientEncounters(patientId, pageable);
        }

        return ResponseEntity.ok(encounters);
    }

    @PutMapping("/{encounterId}/start")
    @Operation(summary = "Start encounter", description = "Changes encounter status to IN_PROGRESS")
    public ResponseEntity<EncounterResponse> startEncounter(
            @Parameter(description = "Encounter ID") @PathVariable UUID encounterId) {

        EncounterResponse response = encounterService.startEncounter(encounterId);
        return ResponseEntity.ok(response);
    }

    @PutMapping("/{encounterId}/complete")
    @Operation(summary = "Complete encounter", description = "Changes encounter status to COMPLETED")
    public ResponseEntity<EncounterResponse> completeEncounter(
            @Parameter(description = "Encounter ID") @PathVariable UUID encounterId) {

        EncounterResponse response = encounterService.completeEncounter(encounterId);
        return ResponseEntity.ok(response);
    }
}

```

### File: ./src/test/java/de/his/encounter/application/service/EncounterServiceTest.java
```java
package de.his.encounter.application.service;

import de.his.encounter.application.dto.CreateEncounterRequest;
import de.his.encounter.application.dto.EncounterResponse;
import de.his.encounter.application.dto.EncounterSummary;
import de.his.encounter.domain.model.Encounter;
import de.his.encounter.domain.model.BillingContext;
import de.his.encounter.domain.model.EncounterStatus;
import de.his.encounter.domain.model.EncounterType;
import de.his.encounter.domain.repository.EncounterRepository;
import de.his.encounter.infrastructure.exception.EncounterNotFoundException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.Optional;
import java.util.UUID;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class EncounterServiceTest {

    @Mock
    private EncounterRepository encounterRepository;

    @InjectMocks
    private EncounterService encounterService;

    private UUID patientId;
    private UUID practitionerId;
    private UUID encounterId;
    private LocalDateTime encounterDate;

    @BeforeEach
    void setUp() {
        patientId = UUID.randomUUID();
        practitionerId = UUID.randomUUID();
        encounterId = UUID.randomUUID();
        encounterDate = LocalDateTime.now().plusDays(1);
    }

    @Test
    void shouldCreateEncounter() {
        // Given
        CreateEncounterRequest request = new CreateEncounterRequest(
                patientId, practitionerId, EncounterType.INITIAL,
                encounterDate, BillingContext.GKV);

        Encounter savedEncounter = createTestEncounter();
        when(encounterRepository.save(any(Encounter.class))).thenReturn(savedEncounter);

        // When
        EncounterResponse response = encounterService.createEncounter(request);

        // Then
        assertThat(response.getId()).isEqualTo(encounterId);
        assertThat(response.getPatientId()).isEqualTo(patientId);
        assertThat(response.getType()).isEqualTo(EncounterType.INITIAL);
        assertThat(response.getStatus()).isEqualTo(EncounterStatus.PLANNED);
        assertThat(response.getBillingContext()).isEqualTo(BillingContext.GKV);

        verify(encounterRepository).save(any(Encounter.class));
    }

    @Test
    void shouldGetEncounter() {
        // Given
        Encounter encounter = createTestEncounter();
        when(encounterRepository.findById(encounterId)).thenReturn(Optional.of(encounter));

        // When
        EncounterResponse response = encounterService.getEncounter(encounterId);

        // Then
        assertThat(response.getId()).isEqualTo(encounterId);
        assertThat(response.getPatientId()).isEqualTo(patientId);
        verify(encounterRepository).findById(encounterId);
    }

    @Test
    void shouldThrowExceptionWhenEncounterNotFound() {
        // Given
        when(encounterRepository.findById(encounterId)).thenReturn(Optional.empty());

        // When & Then
        assertThatThrownBy(() -> encounterService.getEncounter(encounterId))
                .isInstanceOf(EncounterNotFoundException.class)
                .hasMessageContaining(encounterId.toString());

        verify(encounterRepository).findById(encounterId);
    }

    @Test
    void shouldStartEncounter() {
        // Given
        Encounter encounter = createTestEncounter();
        when(encounterRepository.findById(encounterId)).thenReturn(Optional.of(encounter));
        when(encounterRepository.save(encounter)).thenReturn(encounter);

        // When
        EncounterResponse response = encounterService.startEncounter(encounterId);

        // Then
        assertThat(response.getStatus()).isEqualTo(EncounterStatus.IN_PROGRESS);
        verify(encounterRepository).findById(encounterId);
        verify(encounterRepository).save(encounter);
    }

    @Test
    void shouldCompleteEncounter() {
        // Given
        Encounter encounter = createTestEncounter();
        encounter.startEncounter(); // Erst starten, dann beenden
        when(encounterRepository.findById(encounterId)).thenReturn(Optional.of(encounter));
        when(encounterRepository.save(encounter)).thenReturn(encounter);

        // When
        EncounterResponse response = encounterService.completeEncounter(encounterId);

        // Then
        assertThat(response.getStatus()).isEqualTo(EncounterStatus.COMPLETED);
        verify(encounterRepository).findById(encounterId);
        verify(encounterRepository).save(encounter);
    }

    @Test
    void shouldGetPatientEncounters() {
        // Given
        Encounter encounter1 = createTestEncounter();
        Encounter encounter2 = createTestEncounter();
        Page<Encounter> encounterPage = new PageImpl<>(Arrays.asList(encounter1, encounter2));
        Pageable pageable = PageRequest.of(0, 10);

        when(encounterRepository.findByPatientIdOrderByEncounterDateDesc(patientId, pageable))
                .thenReturn(encounterPage);

        // When
        Page<EncounterSummary> result = encounterService.getPatientEncounters(patientId, pageable);

        // Then
        assertThat(result.getContent()).hasSize(2);
        assertThat(result.getContent().get(0).getId()).isEqualTo(encounterId);
        verify(encounterRepository).findByPatientIdOrderByEncounterDateDesc(patientId, pageable);
    }

    private Encounter createTestEncounter() {
        Encounter encounter = new Encounter(
                patientId, practitionerId, EncounterType.INITIAL,
                encounterDate, BillingContext.GKV);
        encounter.setId(encounterId);
        return encounter;
    }
}

```

### File: ./src/test/java/de/his/encounter/ControllerDirectTest.java
```java
package de.his.encounter;

import de.his.encounter.application.dto.CreateEncounterRequest;
import de.his.encounter.application.dto.EncounterResponse;
import de.his.encounter.domain.model.BillingContext;
import de.his.encounter.domain.model.EncounterType;
import de.his.encounter.presentation.controller.EncounterController;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.UUID;

import static org.assertj.core.api.Assertions.*;

@SpringBootTest
@ActiveProfiles("test")
@Transactional
class ControllerDirectTest {

    @Autowired
    private EncounterController encounterController;

    @Test
    void shouldCreateAndRetrieveEncounterViaController() {
        try {
            // Given
            CreateEncounterRequest request = new CreateEncounterRequest(
                    UUID.randomUUID(),
                    UUID.randomUUID(),
                    EncounterType.INITIAL,
                    LocalDateTime.now().plusDays(1),
                    BillingContext.GKV);

            System.out.println("🔍 Creating encounter via controller");

            // When - Create encounter
            ResponseEntity<EncounterResponse> createResponse = encounterController.createEncounter(request);
            System.out.println("✅ Controller create response: " + createResponse.getStatusCode());

            assertThat(createResponse.getStatusCode()).isEqualTo(HttpStatus.CREATED);
            assertThat(createResponse.getBody()).isNotNull();

            UUID encounterId = createResponse.getBody().getId();
            System.out.println("✅ Created encounter via controller: " + encounterId);

            // When - Retrieve encounter
            System.out.println("🔍 Retrieving encounter via controller: " + encounterId);
            ResponseEntity<EncounterResponse> getResponse = encounterController.getEncounter(encounterId);
            System.out.println("✅ Controller get response: " + getResponse.getStatusCode());

            // Then
            assertThat(getResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(getResponse.getBody()).isNotNull();
            assertThat(getResponse.getBody().getId()).isEqualTo(encounterId);

            System.out.println("✅ Controller direct test passed!");

        } catch (Exception e) {
            System.err.println("❌ Error in controller direct test: " + e.getMessage());
            e.printStackTrace();
            throw e;
        }
    }
}

```

### File: ./src/test/java/de/his/encounter/domain/model/EncounterTest.java
```java
package de.his.encounter.domain.model;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.time.LocalDateTime;
import java.util.UUID;

import static org.assertj.core.api.Assertions.*;

class EncounterTest {

    private UUID patientId;
    private UUID practitionerId;
    private LocalDateTime encounterDate;
    private Encounter encounter;

    @BeforeEach
    void setUp() {
        patientId = UUID.randomUUID();
        practitionerId = UUID.randomUUID();
        encounterDate = LocalDateTime.now().plusDays(1);

        encounter = new Encounter(
                patientId, practitionerId, EncounterType.INITIAL,
                encounterDate, BillingContext.GKV);
    }

    @Test
    void shouldCreateEncounterWithPlannedStatus() {
        // Then
        assertThat(encounter.getPatientId()).isEqualTo(patientId);
        assertThat(encounter.getPractitionerId()).isEqualTo(practitionerId);
        assertThat(encounter.getType()).isEqualTo(EncounterType.INITIAL);
        assertThat(encounter.getStatus()).isEqualTo(EncounterStatus.PLANNED);
        assertThat(encounter.getBillingContext()).isEqualTo(BillingContext.GKV);
        assertThat(encounter.getDocumentation()).isEmpty();
    }

    @Test
    void shouldStartEncounterFromPlannedStatus() {
        // When
        encounter.startEncounter();

        // Then
        assertThat(encounter.getStatus()).isEqualTo(EncounterStatus.IN_PROGRESS);
    }

    @Test
    void shouldThrowExceptionWhenStartingNonPlannedEncounter() {
        // Given
        encounter.startEncounter(); // Now IN_PROGRESS

        // When & Then
        assertThatThrownBy(() -> encounter.startEncounter())
                .isInstanceOf(IllegalStateException.class)
                .hasMessageContaining("can only be started from PLANNED status");
    }

    @Test
    void shouldCompleteEncounterFromInProgressStatus() {
        // Given
        encounter.startEncounter(); // First start it

        // When
        encounter.completeEncounter();

        // Then
        assertThat(encounter.getStatus()).isEqualTo(EncounterStatus.COMPLETED);
    }

    @Test
    void shouldThrowExceptionWhenCompletingNonInProgressEncounter() {
        // When & Then (still PLANNED)
        assertThatThrownBy(() -> encounter.completeEncounter())
                .isInstanceOf(IllegalStateException.class)
                .hasMessageContaining("can only be completed from IN_PROGRESS status");
    }

    @Test
    void shouldAddDocumentation() {
        // Given
        EncounterDocumentation documentation = new EncounterDocumentation(
                SOAPSection.SUBJECTIVE, ContentType.TEXT, "Patient complaints", UUID.randomUUID());

        // When
        encounter.addDocumentation(documentation);

        // Then
        assertThat(encounter.getDocumentation()).hasSize(1);
        assertThat(encounter.getDocumentation().get(0)).isEqualTo(documentation);
        assertThat(documentation.getEncounter()).isEqualTo(encounter);
    }

    @Test
    void shouldHandleMultipleDocumentationEntries() {
        // Given
        EncounterDocumentation subjective = new EncounterDocumentation(
                SOAPSection.SUBJECTIVE, ContentType.TEXT, "Patient complaints", UUID.randomUUID());
        EncounterDocumentation objective = new EncounterDocumentation(
                SOAPSection.OBJECTIVE, ContentType.TEXT, "Examination findings", UUID.randomUUID());

        // When
        encounter.addDocumentation(subjective);
        encounter.addDocumentation(objective);

        // Then
        assertThat(encounter.getDocumentation()).hasSize(2);
        assertThat(encounter.getDocumentation()).containsExactly(subjective, objective);
    }
}

```

### File: ./src/test/java/de/his/encounter/EncounterServiceIntegrationTest.java
```java
package de.his.encounter;

import de.his.encounter.application.dto.CreateEncounterRequest;
import de.his.encounter.application.dto.EncounterResponse;
import de.his.encounter.domain.model.BillingContext;
import de.his.encounter.domain.model.EncounterStatus;
import de.his.encounter.domain.model.EncounterType;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureWebMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.UUID;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWebMvc
@ActiveProfiles("test")
@Transactional
class EncounterServiceIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    void shouldCreateAndRetrieveEncounter() throws Exception {
        // Given
        CreateEncounterRequest request = new CreateEncounterRequest(
                UUID.randomUUID(),
                UUID.randomUUID(),
                EncounterType.INITIAL,
                LocalDateTime.now().plusDays(1),
                BillingContext.GKV);

        // When - Create encounter
        String createResponse = mockMvc.perform(post("/api/v1/encounters")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.type").value("INITIAL"))
                .andExpect(jsonPath("$.status").value("PLANNED"))
                .andReturn().getResponse().getContentAsString();

        EncounterResponse created = objectMapper.readValue(createResponse, EncounterResponse.class);

        // Then - Retrieve encounter
        mockMvc.perform(get("/api/v1/encounters/{id}", created.getId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").value(created.getId().toString()))
                .andExpect(jsonPath("$.type").value("INITIAL"));
    }

    @Test
    void shouldHandleEncounterLifecycle() throws Exception {
        // Given - Create encounter
        CreateEncounterRequest request = new CreateEncounterRequest(
                UUID.randomUUID(),
                UUID.randomUUID(),
                EncounterType.EMERGENCY,
                LocalDateTime.now(),
                BillingContext.GKV);

        String createResponse = mockMvc.perform(post("/api/v1/encounters")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isCreated())
                .andReturn().getResponse().getContentAsString();

        EncounterResponse created = objectMapper.readValue(createResponse, EncounterResponse.class);

        // When - Start encounter
        mockMvc.perform(put("/api/v1/encounters/{id}/start", created.getId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.status").value("IN_PROGRESS"));

        // Then - Complete encounter
        mockMvc.perform(put("/api/v1/encounters/{id}/complete", created.getId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.status").value("COMPLETED"));
    }

    @Test
    void shouldReturn404ForNonExistentEncounter() throws Exception {
        UUID nonExistentId = UUID.randomUUID();

        mockMvc.perform(get("/api/v1/encounters/{id}", nonExistentId))
                .andExpect(status().isNotFound())
                .andExpect(jsonPath("$.code").value("ENCOUNTER_NOT_FOUND"));
    }

    @Test
    void shouldValidateRequestFields() throws Exception {
        // Given - Invalid request
        CreateEncounterRequest invalidRequest = new CreateEncounterRequest();

        // When & Then
        mockMvc.perform(post("/api/v1/encounters")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(invalidRequest)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.code").value("VALIDATION_ERROR"));
    }
}

```

### File: ./src/test/java/de/his/encounter/HttpIntegrationTest.java
```java
package de.his.encounter;

import de.his.encounter.application.dto.CreateEncounterRequest;
import de.his.encounter.application.dto.EncounterResponse;
import de.his.encounter.domain.model.BillingContext;
import de.his.encounter.domain.model.EncounterStatus;
import de.his.encounter.domain.model.EncounterType;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.test.context.ActiveProfiles;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.UUID;

import static org.assertj.core.api.Assertions.*;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
class HttpIntegrationTest {

    @LocalServerPort
    private int port;

    @Autowired
    private TestRestTemplate restTemplate;

    private String getBaseUrl() {
        return "http://localhost:" + port + "/api/v1/encounters";
    }

    @Test
    void shouldCreateEncounterViaHttp() {
        // Given
        CreateEncounterRequest request = new CreateEncounterRequest(
                UUID.randomUUID(),
                UUID.randomUUID(),
                EncounterType.INITIAL,
                LocalDateTime.now().plusDays(1),
                BillingContext.GKV);

        // When
        ResponseEntity<EncounterResponse> response = restTemplate.postForEntity(
                getBaseUrl(), request, EncounterResponse.class);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().getType()).isEqualTo(EncounterType.INITIAL);
        assertThat(response.getBody().getStatus()).isEqualTo(EncounterStatus.PLANNED);

        System.out.println("✅ Created encounter: " + response.getBody().getId());
    }

    @Test
    void shouldRetrieveEncounterViaHttp() {
        // Given - Create encounter first
        CreateEncounterRequest request = new CreateEncounterRequest(
                UUID.randomUUID(),
                UUID.randomUUID(),
                EncounterType.FOLLOW_UP,
                LocalDateTime.now().plusHours(2),
                BillingContext.PKV);

        ResponseEntity<EncounterResponse> createResponse = restTemplate.postForEntity(
                getBaseUrl(), request, EncounterResponse.class);

        assertThat(createResponse.getStatusCode()).isEqualTo(HttpStatus.CREATED);
        UUID encounterId = createResponse.getBody().getId();
        System.out.println("✅ Created encounter for retrieval test: " + encounterId);

        // When
        ResponseEntity<EncounterResponse> getResponse = restTemplate.getForEntity(
                getBaseUrl() + "/" + encounterId, EncounterResponse.class);

        // Then
        assertThat(getResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(getResponse.getBody().getId()).isEqualTo(encounterId);
        assertThat(getResponse.getBody().getType()).isEqualTo(EncounterType.FOLLOW_UP);

        System.out.println("✅ Retrieved encounter successfully");
    }

    @Test
    void shouldReturn404ForNonExistentEncounter() {
        // Given
        UUID nonExistentId = UUID.randomUUID();

        // When
        ResponseEntity<Map> response = restTemplate.getForEntity(
                getBaseUrl() + "/" + nonExistentId, Map.class);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().get("code")).isEqualTo("ENCOUNTER_NOT_FOUND");

        System.out.println("✅ 404 error handling works correctly");
    }

    @Test
    void shouldHandleEncounterLifecycleViaHttp() {
        // Given - Create encounter
        CreateEncounterRequest request = new CreateEncounterRequest(
                UUID.randomUUID(),
                UUID.randomUUID(),
                EncounterType.EMERGENCY,
                LocalDateTime.now(),
                BillingContext.GKV);

        ResponseEntity<EncounterResponse> createResponse = restTemplate.postForEntity(
                getBaseUrl(), request, EncounterResponse.class);
        UUID encounterId = createResponse.getBody().getId();

        System.out.println("✅ Created encounter for lifecycle test: " + encounterId);

        // When - Start encounter
        ResponseEntity<EncounterResponse> startResponse = restTemplate.exchange(
                getBaseUrl() + "/" + encounterId + "/start",
                HttpMethod.PUT, // Korrigiert: HttpMethod.PUT statt org.springframework.http.HttpMethod.PUT
                null,
                EncounterResponse.class);

        // Then
        assertThat(startResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(startResponse.getBody().getStatus()).isEqualTo(EncounterStatus.IN_PROGRESS);

        System.out.println("✅ Started encounter successfully");

        // When - Complete encounter
        ResponseEntity<EncounterResponse> completeResponse = restTemplate.exchange(
                getBaseUrl() + "/" + encounterId + "/complete",
                HttpMethod.PUT, // Korrigiert: HttpMethod.PUT
                null,
                EncounterResponse.class);

        // Then
        assertThat(completeResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(completeResponse.getBody().getStatus()).isEqualTo(EncounterStatus.COMPLETED);

        System.out.println("✅ Completed encounter successfully");
    }

    @Test
    void shouldValidateRequestFields() {
        // Given - Invalid request (missing required fields)
        CreateEncounterRequest invalidRequest = new CreateEncounterRequest();

        // When
        ResponseEntity<Map> response = restTemplate.postForEntity(
                getBaseUrl(), invalidRequest, Map.class);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().get("code")).isEqualTo("VALIDATION_ERROR");

        System.out.println("✅ Validation error handling works correctly");
    }
}

```

### File: ./src/test/java/de/his/encounter/MinimalHttpTest.java
```java
package de.his.encounter;

import de.his.encounter.application.dto.CreateEncounterRequest;
import de.his.encounter.domain.model.BillingContext;
import de.his.encounter.domain.model.EncounterType;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.http.ResponseEntity;
import org.springframework.test.context.ActiveProfiles;

import java.time.LocalDateTime;
import java.util.UUID;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
class MinimalHttpTest {

    @LocalServerPort
    private int port;

    @Autowired
    private TestRestTemplate restTemplate;

    @Test
    void shouldCreateEncounterOnly() {
        try {
            // Given
            String baseUrl = "http://localhost:" + port + "/api/v1/encounters";

            CreateEncounterRequest request = new CreateEncounterRequest(
                    UUID.randomUUID(),
                    UUID.randomUUID(),
                    EncounterType.INITIAL,
                    LocalDateTime.now().plusDays(1),
                    BillingContext.GKV);

            System.out.println("🔍 Testing URL: " + baseUrl);
            System.out.println("🔍 Request: " + request.getType());

            // When
            ResponseEntity<String> response = restTemplate.postForEntity(
                    baseUrl, request, String.class);

            // Then
            System.out.println("📋 Response Status: " + response.getStatusCode());
            System.out.println("📋 Response Headers: " + response.getHeaders());
            System.out.println("📋 Response Body: " + response.getBody());

            if (response.getStatusCode().is2xxSuccessful()) {
                System.out.println("✅ Minimal HTTP test passed!");
            } else {
                System.err.println("❌ HTTP test failed with status: " + response.getStatusCode());
            }

        } catch (Exception e) {
            System.err.println("❌ Error in minimal HTTP test: " + e.getMessage());
            e.printStackTrace();
        }
    }
}

```

### File: ./src/test/java/de/his/encounter/presentation/controller/EncounterControllerTest.java
```java
package de.his.encounter.presentation.controller;

import de.his.encounter.application.dto.CreateEncounterRequest;
import de.his.encounter.application.dto.EncounterResponse;
import de.his.encounter.application.service.EncounterService;
import de.his.encounter.domain.model.BillingContext;
import de.his.encounter.domain.model.EncounterStatus;
import de.his.encounter.domain.model.EncounterType;
import de.his.encounter.infrastructure.exception.EncounterNotFoundException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import java.time.LocalDateTime;
import java.util.Collections;
import java.util.UUID;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class EncounterControllerTest {

    @Mock
    private EncounterService encounterService;

    @InjectMocks
    private EncounterController encounterController;

    private UUID patientId;
    private UUID practitionerId;
    private UUID encounterId;
    private LocalDateTime encounterDate;

    @BeforeEach
    void setUp() {
        patientId = UUID.randomUUID();
        practitionerId = UUID.randomUUID();
        encounterId = UUID.randomUUID();
        encounterDate = LocalDateTime.now().plusDays(1);
    }

    @Test
    void shouldCreateEncounter() {
        // Given
        CreateEncounterRequest request = new CreateEncounterRequest(
                patientId, practitionerId, EncounterType.INITIAL,
                encounterDate, BillingContext.GKV);

        EncounterResponse expectedResponse = new EncounterResponse(
                encounterId, patientId, practitionerId, EncounterType.INITIAL,
                encounterDate, EncounterStatus.PLANNED, BillingContext.GKV,
                Collections.emptyList(), LocalDateTime.now(), LocalDateTime.now());

        when(encounterService.createEncounter(any(CreateEncounterRequest.class)))
                .thenReturn(expectedResponse);

        // When
        ResponseEntity<EncounterResponse> response = encounterController.createEncounter(request);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().getId()).isEqualTo(encounterId);
        assertThat(response.getBody().getType()).isEqualTo(EncounterType.INITIAL);
        assertThat(response.getBody().getStatus()).isEqualTo(EncounterStatus.PLANNED);
    }

    @Test
    void shouldGetEncounter() {
        // Given
        EncounterResponse expectedResponse = new EncounterResponse(
                encounterId, patientId, practitionerId, EncounterType.FOLLOW_UP,
                encounterDate, EncounterStatus.PLANNED, BillingContext.PKV,
                Collections.emptyList(), LocalDateTime.now(), LocalDateTime.now());

        when(encounterService.getEncounter(encounterId)).thenReturn(expectedResponse);

        // When
        ResponseEntity<EncounterResponse> response = encounterController.getEncounter(encounterId);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().getId()).isEqualTo(encounterId);
        assertThat(response.getBody().getType()).isEqualTo(EncounterType.FOLLOW_UP);
    }

    @Test
    void shouldStartEncounter() {
        // Given
        EncounterResponse expectedResponse = new EncounterResponse(
                encounterId, patientId, practitionerId, EncounterType.INITIAL,
                encounterDate, EncounterStatus.IN_PROGRESS, BillingContext.GKV,
                Collections.emptyList(), LocalDateTime.now(), LocalDateTime.now());

        when(encounterService.startEncounter(encounterId)).thenReturn(expectedResponse);

        // When
        ResponseEntity<EncounterResponse> response = encounterController.startEncounter(encounterId);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().getStatus()).isEqualTo(EncounterStatus.IN_PROGRESS);
    }

    @Test
    void shouldCompleteEncounter() {
        // Given
        EncounterResponse expectedResponse = new EncounterResponse(
                encounterId, patientId, practitionerId, EncounterType.INITIAL,
                encounterDate, EncounterStatus.COMPLETED, BillingContext.GKV,
                Collections.emptyList(), LocalDateTime.now(), LocalDateTime.now());

        when(encounterService.completeEncounter(encounterId)).thenReturn(expectedResponse);

        // When
        ResponseEntity<EncounterResponse> response = encounterController.completeEncounter(encounterId);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().getStatus()).isEqualTo(EncounterStatus.COMPLETED);
    }
}

```

### File: ./src/test/java/de/his/encounter/ServiceDirectTest.java
```java
package de.his.encounter;

import de.his.encounter.application.dto.CreateEncounterRequest;
import de.his.encounter.application.dto.EncounterResponse;
import de.his.encounter.application.service.EncounterService;
import de.his.encounter.domain.model.BillingContext;
import de.his.encounter.domain.model.EncounterType;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.UUID;

import static org.assertj.core.api.Assertions.*;

@SpringBootTest
@ActiveProfiles("test")
@Transactional
class ServiceDirectTest {

    @Autowired
    private EncounterService encounterService;

    @Test
    void shouldCreateAndRetrieveEncounterDirectly() {
        try {
            // Given
            CreateEncounterRequest request = new CreateEncounterRequest(
                    UUID.randomUUID(),
                    UUID.randomUUID(),
                    EncounterType.INITIAL,
                    LocalDateTime.now().plusDays(1),
                    BillingContext.GKV);

            System.out.println("🔍 Creating encounter with request: " + request.getType());

            // When - Create encounter
            EncounterResponse created = encounterService.createEncounter(request);
            System.out.println("✅ Created encounter: " + created.getId());

            // When - Retrieve encounter
            System.out.println("🔍 Retrieving encounter: " + created.getId());
            EncounterResponse retrieved = encounterService.getEncounter(created.getId());
            System.out.println("✅ Retrieved encounter: " + retrieved.getId());

            // Then
            assertThat(retrieved.getId()).isEqualTo(created.getId());
            assertThat(retrieved.getType()).isEqualTo(EncounterType.INITIAL);

            System.out.println("✅ Service direct test passed!");

        } catch (Exception e) {
            System.err.println("❌ Error in service direct test: " + e.getMessage());
            e.printStackTrace();
            throw e;
        }
    }
}

```

### File: ./src/test/java/de/his/encounter/ServiceIntegrationTest.java
```java
package de.his.encounter;

import de.his.encounter.application.dto.CreateEncounterRequest;
import de.his.encounter.application.dto.EncounterResponse;
import de.his.encounter.application.service.EncounterService;
import de.his.encounter.domain.model.BillingContext;
import de.his.encounter.domain.model.EncounterStatus;
import de.his.encounter.domain.model.EncounterType;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.UUID;

import static org.assertj.core.api.Assertions.*;

@SpringBootTest
@ActiveProfiles("test")
@Transactional
class ServiceIntegrationTest {

    @Autowired
    private EncounterService encounterService;

    @Test
    void shouldCreateAndRetrieveEncounter() {
        // Given
        CreateEncounterRequest request = new CreateEncounterRequest(
                UUID.randomUUID(),
                UUID.randomUUID(),
                EncounterType.INITIAL,
                LocalDateTime.now().plusDays(1),
                BillingContext.GKV);

        // When - Create encounter
        EncounterResponse created = encounterService.createEncounter(request);

        // Then - Verify creation
        assertThat(created).isNotNull();
        assertThat(created.getId()).isNotNull();
        assertThat(created.getType()).isEqualTo(EncounterType.INITIAL);
        assertThat(created.getStatus()).isEqualTo(EncounterStatus.PLANNED);

        // When - Retrieve encounter
        EncounterResponse retrieved = encounterService.getEncounter(created.getId());

        // Then - Verify retrieval
        assertThat(retrieved.getId()).isEqualTo(created.getId());
        assertThat(retrieved.getType()).isEqualTo(EncounterType.INITIAL);
    }

    @Test
    void shouldHandleEncounterLifecycle() {
        // Given
        CreateEncounterRequest request = new CreateEncounterRequest(
                UUID.randomUUID(),
                UUID.randomUUID(),
                EncounterType.EMERGENCY,
                LocalDateTime.now(),
                BillingContext.GKV);

        EncounterResponse created = encounterService.createEncounter(request);

        // When - Start and complete encounter
        EncounterResponse started = encounterService.startEncounter(created.getId());
        EncounterResponse completed = encounterService.completeEncounter(created.getId());

        // Then
        assertThat(started.getStatus()).isEqualTo(EncounterStatus.IN_PROGRESS);
        assertThat(completed.getStatus()).isEqualTo(EncounterStatus.COMPLETED);
    }
}

```

### File: ./src/test/java/de/his/encounter/TestDataBuilder.java
```java
package de.his.encounter;

import de.his.encounter.application.dto.CreateEncounterRequest;
import de.his.encounter.domain.model.*;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Builder-Klasse für Test-Daten
 */
public class TestDataBuilder {

    public static CreateEncounterRequest.Builder createEncounterRequest() {
        return new CreateEncounterRequest.Builder();
    }

    public static Encounter.Builder encounter() {
        return new Encounter.Builder();
    }

    public static EncounterDocumentation.Builder encounterDocumentation() {
        return new EncounterDocumentation.Builder();
    }

    public static class CreateEncounterRequest {
        public static class Builder {
            private UUID patientId = UUID.randomUUID();
            private UUID practitionerId = UUID.randomUUID();
            private EncounterType type = EncounterType.INITIAL;
            private LocalDateTime encounterDate = LocalDateTime.now().plusDays(1);
            private BillingContext billingContext = BillingContext.GKV;

            public Builder patientId(UUID patientId) {
                this.patientId = patientId;
                return this;
            }

            public Builder practitionerId(UUID practitionerId) {
                this.practitionerId = practitionerId;
                return this;
            }

            public Builder type(EncounterType type) {
                this.type = type;
                return this;
            }

            public Builder encounterDate(LocalDateTime encounterDate) {
                this.encounterDate = encounterDate;
                return this;
            }

            public Builder billingContext(BillingContext billingContext) {
                this.billingContext = billingContext;
                return this;
            }

            public de.his.encounter.application.dto.CreateEncounterRequest build() {
                return new de.his.encounter.application.dto.CreateEncounterRequest(
                        patientId, practitionerId, type, encounterDate, billingContext);
            }
        }
    }

    public static class Encounter {
        public static class Builder {
            private UUID patientId = UUID.randomUUID();
            private UUID practitionerId = UUID.randomUUID();
            private EncounterType type = EncounterType.INITIAL;
            private LocalDateTime encounterDate = LocalDateTime.now().plusDays(1);
            private BillingContext billingContext = BillingContext.GKV;

            public Builder patientId(UUID patientId) {
                this.patientId = patientId;
                return this;
            }

            public Builder practitionerId(UUID practitionerId) {
                this.practitionerId = practitionerId;
                return this;
            }

            public Builder type(EncounterType type) {
                this.type = type;
                return this;
            }

            public Builder encounterDate(LocalDateTime encounterDate) {
                this.encounterDate = encounterDate;
                return this;
            }

            public Builder billingContext(BillingContext billingContext) {
                this.billingContext = billingContext;
                return this;
            }

            public de.his.encounter.domain.model.Encounter build() {
                return new de.his.encounter.domain.model.Encounter(
                        patientId, practitionerId, type, encounterDate, billingContext);
            }
        }
    }

    public static class EncounterDocumentation {
        public static class Builder {
            private SOAPSection soapSection = SOAPSection.SUBJECTIVE;
            private ContentType contentType = ContentType.TEXT;
            private String content = "Test content";
            private UUID authorId = UUID.randomUUID();

            public Builder soapSection(SOAPSection soapSection) {
                this.soapSection = soapSection;
                return this;
            }

            public Builder contentType(ContentType contentType) {
                this.contentType = contentType;
                return this;
            }

            public Builder content(String content) {
                this.content = content;
                return this;
            }

            public Builder authorId(UUID authorId) {
                this.authorId = authorId;
                return this;
            }

            public de.his.encounter.domain.model.EncounterDocumentation build() {
                return new de.his.encounter.domain.model.EncounterDocumentation(
                        soapSection, contentType, content, authorId);
            }
        }
    }
}

```

### File: ./src/main/resources/application-docker-minimal.yml
```yml
spring:
  application:
    name: encounter-service

  # PostgreSQL Connection - KORRIGIERT für einheitliche DB
  datasource:
    url: jdbc:postgresql://postgres:5432/his_db
    username: his_user
    password: dev_password
    driver-class-name: org.postgresql.Driver
    # Connection Pool Optimierung
    hikari:
      maximum-pool-size: 10
      minimum-idle: 2
      connection-timeout: 20000
      idle-timeout: 300000
      max-lifetime: 1200000
      leak-detection-threshold: 60000

  # JPA/Hibernate Configuration
  jpa:
    # ✅ KRITISCHER FIX: PostgreSQL statt H2 Dialect
    database-platform: org.hibernate.dialect.PostgreSQLDialect
    hibernate:
      # ✅ FIX: update statt create-drop (behält Daten bei Restart)
      ddl-auto: update
      # ✅ FIX: Naming Strategy für PostgreSQL
      naming:
        physical-strategy: org.hibernate.boot.model.naming.CamelCaseToUnderscoresNamingStrategy
        implicit-strategy: org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy
    # SQL Logging für Debugging (kann später deaktiviert werden)
    show-sql: true
    properties:
      hibernate:
        # ✅ FIX: Schema explizit definiert - KORRIGIERT auf his_encounter
        default_schema: his_encounter
        # SQL Formatierung für bessere Lesbarkeit
        format_sql: true
        # PostgreSQL-spezifische Optimierungen
        jdbc:
          lob:
            non_contextual_creation: true
          batch_size: 20
        # Performance Optimierung
        cache:
          use_second_level_cache: false
          use_query_cache: false

  # ✅ KRITISCHER FIX: Security Configuration hinzugefügt
  security:
    user:
      name: admin
      password: dev-password
      roles: ADMIN

  # Disable H2 Console explizit
  h2:
    console:
      enabled: false

# Feign Client Configuration
services:
  patient:
    url: http://patient-service:8081

feign:
  client:
    config:
      default:
        connect-timeout: 5000
        read-timeout: 10000
        logger-level: full

# Logging Configuration
logging:
  level:
    # Hibernate SQL Logging (für Debugging)
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
    # HikariCP Connection Pool Logging
    com.zaxxer.hikari.HikariConfig: DEBUG
    com.zaxxer.hikari: INFO
    # Feign Client Logging
    org.springframework.cloud.openfeign: DEBUG
    feign: DEBUG
    # Application Specific Logging
    de.his.encounter: DEBUG
    # Root Logger (kann auf INFO gestellt werden in Production)
    root: INFO

# Management Endpoints (Actuator)
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,env,configprops,loggers,mappings
  endpoint:
    health:
      show-details: always
      show-components: always
    info:
      env:
        enabled: true

# Server Configuration - KORRIGIERT auf Port 8082
server:
  port: 8082
  servlet:
    context-path: /
  tomcat:
    threads:
      max: 200
      min-spare: 10

```

### File: ./src/main/resources/application-docker.yml
```yml
server:
  port: 8082

spring:
  application:
    name: encounter-service
  datasource:
    url: ${SPRING_DATASOURCE_URL:jdbc:postgresql://postgres:5432/his_encounter}
    username: ${SPRING_DATASOURCE_USERNAME:his_user}
    password: ${SPRING_DATASOURCE_PASSWORD:dev_password}
    driver-class-name: org.postgresql.Driver
  jpa:
    hibernate:
      ddl-auto: create-drop
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
    show-sql: false
  flyway:
    enabled: false

services:
  patient:
    url: ${SERVICES_PATIENT_URL:http://patient-service:8081}

feign:
  client:
    config:
      patient-service:
        connectTimeout: 5000
        readTimeout: 10000
        loggerLevel: basic

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: always

logging:
  level:
    de.his.encounter: INFO
    org.springframework.cloud.openfeign: INFO
  file:
    name: logs/encounter-service.log

springdoc:
  api-docs:
    path: /api-docs
  swagger-ui:
    path: /swagger-ui.html

```

### File: ./src/main/resources/application.yml
```yml
server:
  port: 8082

spring:
  application:
    name: encounter-service

  datasource:
    url: jdbc:postgresql://postgres:5432/his_db
    username: his_user
    password: dev_password
    driver-class-name: org.postgresql.Driver

  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        default_schema: his_encounter
        format_sql: true

  flyway:
    enabled: true

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: always

logging:
  level:
    de.his.encounter: DEBUG
    org.hibernate.SQL: DEBUG

feign:
  client:
    config:
      default:
        connectTimeout: 5000
        readTimeout: 10000

services:
  patient:
    url: http://patient-service:8081

springdoc:
  api-docs:
    path: /api-docs
  swagger-ui:
    path: /swagger-ui.html
    enabled: true

```

### File: ./src/test/resources/application-test.yml
```yml
spring:
  datasource:
    url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.H2Dialect
  
  h2:
    console:
      enabled: true

  flyway:
    enabled: false  # Für Tests deaktiviert, da create-drop verwendet wird

logging:
  level:
    de.his.encounter: DEBUG
    org.springframework.web: DEBUG
    org.hibernate.SQL: DEBUG
    org.springframework.test: DEBUG

```

### File: ./.mvn/wrapper/maven-wrapper.properties
```properties
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.9/apache-maven-3.9.9-bin.zip

```

### File: ./pom.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.3.0</version>
        <relativePath/>
    </parent>

    <groupId>de.his</groupId>
    <artifactId>his-encounter-service</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <name>HIS Encounter Service</name>
    <description>HIS Encounter Management Service</description>

    <properties>
        <java.version>21</java.version>
        <spring-cloud.version>2023.0.1</spring-cloud.version>
        <flyway.version>10.17.0</flyway.version>
        <testcontainers.version>1.19.3</testcontainers.version>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <!-- Security Starter -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- ✅ FLYWAY - AKTUALISIERTE VERSION MIT POSTGRESQL 15 SUPPORT -->
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
            <version>${flyway.version}</version>
        </dependency>

        <!-- ✅ FLYWAY POSTGRESQL PLUGIN - EXPLIZIT HINZUGEFÜGT -->
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-database-postgresql</artifactId>
            <version>${flyway.version}</version>
        </dependency>

        <!-- In-Memory DB für Tests -->
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- JSON Processing -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>

        <!-- OpenAPI/Swagger -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>2.5.0</version>
        </dependency>

        <!-- Feign Client -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>

        <!-- Load Balancer für Feign -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-loadbalancer</artifactId>
        </dependency>

        <!-- Test Dependencies - ✅ KORRIGIERTE SCOPES -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>postgresql</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <dependency>
                <groupId>org.testcontainers</groupId>
                <artifactId>testcontainers-bom</artifactId>
                <version>${testcontainers.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.13.0</version>
                <configuration>
                    <release>21</release>
                </configuration>
            </plugin>

            <!-- ✅ FLYWAY MAVEN PLUGIN - AKTUALISIERTE VERSION -->
            <plugin>
                <groupId>org.flywaydb</groupId>
                <artifactId>flyway-maven-plugin</artifactId>
                <version>${flyway.version}</version>
                <configuration>
                    <url>jdbc:postgresql://localhost:5432/his_db</url>
                    <user>his_user</user>
                    <password>dev_password</password>
                    <schemas>
                        <schema>his_encounter</schema>
                    </schemas>
                    <locations>
                        <location>classpath:db/migration</location>
                    </locations>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

### File: ./docker/postgres/init.sql
```sql
-- Wird beim ersten Start der PostgreSQL-Container ausgeführt

-- UUID Extension aktivieren
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Development Seed Data (optional)
-- Beispiel-Practitioner für Development
-- Diese Tabellen werden später durch andere Services erstellt
-- Hier nur als Referenz für lokale Tests

```

### File: ./src/main/resources/db/migration/V1__Create_encounters_table.sql
```sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE encounters (
    encounter_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    patient_id UUID NOT NULL,
    practitioner_id UUID NOT NULL,
    encounter_type VARCHAR(50) NOT NULL,
    encounter_date TIMESTAMP NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'PLANNED',
    billing_context VARCHAR(50),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    version BIGINT NOT NULL DEFAULT 0
);

-- Indizes für Performance
CREATE INDEX idx_encounters_patient_date ON encounters(patient_id, encounter_date DESC);
CREATE INDEX idx_encounters_practitioner ON encounters(practitioner_id);
CREATE INDEX idx_encounters_status ON encounters(status);
CREATE INDEX idx_encounters_date ON encounters(encounter_date);

-- Trigger für updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_encounters_updated_at
    BEFORE UPDATE ON encounters
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

```

### File: ./src/main/resources/db/migration/V2__Create_encounter_documentation_table.sql
```sql
CREATE TABLE encounter_documentation (
    documentation_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    encounter_id UUID NOT NULL REFERENCES encounters(encounter_id) ON DELETE CASCADE,
    soap_section VARCHAR(50) NOT NULL,
    content_type VARCHAR(50) NOT NULL,
    content TEXT,
    structured_content JSONB,
    author_id UUID NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Indizes für SOAP-Dokumentation
CREATE INDEX idx_documentation_encounter ON encounter_documentation(encounter_id);
CREATE INDEX idx_documentation_soap_section ON encounter_documentation(encounter_id, soap_section);
CREATE INDEX idx_documentation_author ON encounter_documentation(author_id);
CREATE INDEX idx_documentation_date ON encounter_documentation(created_at);

-- JSONB Index für strukturierte Suchen
CREATE INDEX idx_documentation_structured_content ON encounter_documentation 
    USING GIN (structured_content);

```

### File: ./Dockerfile
```dockerfile
FROM eclipse-temurin:21-jdk AS build

WORKDIR /app

# Cache Maven dependencies
COPY pom.xml .
COPY .mvn .mvn
COPY mvnw .
RUN ./mvnw dependency:go-offline -B

# Build application
COPY src src
RUN ./mvnw package -DskipTests

# Runtime stage
FROM eclipse-temurin:21-jre

WORKDIR /app

# Create non-root user (Ubuntu/Debian syntax)
RUN groupadd -g 1001 appgroup && \
    useradd -r -u 1001 -g appgroup appuser

# Copy application
COPY --from=build /app/target/*.jar app.jar

# Set ownership
RUN chown appuser:appgroup app.jar

# Switch to non-root user
USER appuser

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8081/actuator/health || exit 1

EXPOSE 8081

ENTRYPOINT ["java", "-jar", "app.jar"]
```

