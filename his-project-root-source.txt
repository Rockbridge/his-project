# HIS Project Root - Configuration and Infrastructure Files
Generated: Mo 11 Aug 2025 23:28:50 CEST
Project: Hospital Information System (HIS) - Root Directory
=========================================================

## Root Directory Structure
```
./.vscode/settings.json
./complete-his-test.sh
./create-patients.sh
./debug.sh
./docker-compose-minimal.yml
./docker-compose.dev.yml
./extract-source-files Kopie.sh
./extract-source-files.sh
./frontend_working_solution.sh
./his_curl_testdata.sh
./his-api-gateway/API Gateway-source.txt
./his-api-gateway/Dockerfile
./his-api-gateway/pom.xml
./his-complete-documentation.md
./his-encounter-service/Dockerfile
./his-encounter-service/Encounter Service-source.txt
./his-encounter-service/exception_tests.sh
./his-encounter-service/pom.xml
./his-frontend/package-lock.json
./his-frontend/package.json
./his-frontend/React Frontend-source.txt
./his-frontend/README.md
./his-patient-service/create_java.sh
./his-patient-service/Dockerfile
./his-patient-service/Patient Service-source.txt
./his-patient-service/pom.xml
./his-project-root-source.txt
./init-scripts/Init Scripts-source.txt
./setup-elk.sh
```

## Available Services
```
drwxr-xr-x  14 mhn  staff      448 10 Aug 08:34 his-api-gateway
drwxr-xr-x@ 19 mhn  staff      608 10 Aug 16:17 his-encounter-service
drwxr-xr-x  14 mhn  staff      448 11 Aug 21:42 his-frontend
drwxr-xr-x  18 mhn  staff      576 10 Aug 16:59 his-patient-service
drwxr-xr-x   5 mhn  staff      160 10 Aug 08:39 init-scripts
```

## Root Configuration Files

### File: ./docker-compose-minimal.yml
```yaml
version: "3.8"

services:
  # PostgreSQL Database - Core Infrastructure
  postgres:
    image: postgres:15-alpine
    container_name: his-postgres-minimal
    environment:
      # ‚úÖ Konsistent mit application-docker-minimal.yml
      POSTGRES_DB: his_db
      POSTGRES_USER: his_user
      POSTGRES_PASSWORD: dev_password
      # PostgreSQL Optimierungen
      POSTGRES_INITDB_ARGS: "--encoding=UTF-8 --lc-collate=C --lc-ctype=C"
    volumes:
      - postgres_data_minimal:/var/lib/postgresql/data
      - ./init-scripts:/docker-entrypoint-initdb.d:ro
    ports:
      - "5432:5432"
    networks:
      - his-network-minimal
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U his_user -d his_db"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    restart: unless-stopped

  # Redis - Caching & Rate Limiting
  redis:
    image: redis:7-alpine
    container_name: his-redis-minimal
    command: redis-server --appendonly yes --maxmemory 256mb --maxmemory-policy allkeys-lru
    volumes:
      - redis_data_minimal:/data
    ports:
      - "6379:6379"
    networks:
      - his-network-minimal
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 3
      start_period: 10s
    restart: unless-stopped

  # Patient Service - Port 8081
  patient-service:
    build:
      context: ./his-patient-service
      dockerfile: Dockerfile
    container_name: his-patient-service-minimal
    environment:
      # Database Configuration
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/his_db
      SPRING_DATASOURCE_USERNAME: his_user
      SPRING_DATASOURCE_PASSWORD: dev_password
      # JPA Configuration
      SPRING_JPA_HIBERNATE_DDL_AUTO: update
      SPRING_JPA_SHOW_SQL: true
      SPRING_JPA_PROPERTIES_HIBERNATE_FORMAT_SQL: true
      SPRING_JPA_PROPERTIES_HIBERNATE_DEFAULT_SCHEMA: his_patient
      # Profile Configuration
      SPRING_PROFILES_ACTIVE: docker-minimal
      # Logging Configuration
      LOGGING_LEVEL_DE_HIS_PATIENT: DEBUG
      LOGGING_LEVEL_ORG_HIBERNATE_SQL: DEBUG
      LOGGING_LEVEL_ROOT: INFO
      # Application Configuration
      SERVER_PORT: 8081
      MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE: health,info,metrics
      MANAGEMENT_ENDPOINT_HEALTH_SHOW_DETAILS: always
      # Security Configuration
      SPRING_SECURITY_USER_NAME: admin
      SPRING_SECURITY_USER_PASSWORD: dev-password
      SPRING_SECURITY_USER_ROLES: ADMIN
    ports:
      - "8081:8081"
    networks:
      - his-network-minimal
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
      test:
        [
          "CMD",
          "wget",
          "--no-verbose",
          "--tries=1",
          "--spider",
          "http://localhost:8081/actuator/health",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    restart: unless-stopped
    volumes:
      - ./logs/patient:/app/logs

  # Encounter Service - Port 8082 ‚úÖ KORREKT EINGER√úCKT
  encounter-service:
    build:
      context: ./his-encounter-service
      dockerfile: Dockerfile
    container_name: his-encounter-service-minimal
    environment:
      # Database Configuration - KORRIGIERT
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/his_db
      SPRING_DATASOURCE_USERNAME: his_user
      SPRING_DATASOURCE_PASSWORD: dev_password
      SPRING_DATASOURCE_DRIVER_CLASS_NAME: org.postgresql.Driver
      # JPA Configuration - KORRIGIERT
      SPRING_JPA_HIBERNATE_DDL_AUTO: update
      SPRING_JPA_SHOW_SQL: true
      SPRING_JPA_DATABASE_PLATFORM: org.hibernate.dialect.PostgreSQLDialect
      SPRING_JPA_PROPERTIES_HIBERNATE_DEFAULT_SCHEMA: his_encounter
      SPRING_JPA_PROPERTIES_HIBERNATE_DIALECT: org.hibernate.dialect.PostgreSQLDialect
      # Explizit H2 deaktivieren
      SPRING_H2_CONSOLE_ENABLED: false
      # Security Configuration - NEU
      SPRING_SECURITY_USER_NAME: admin
      SPRING_SECURITY_USER_PASSWORD: dev-password
      SPRING_SECURITY_USER_ROLES: ADMIN
      # Profile Configuration
      SPRING_PROFILES_ACTIVE: docker-minimal
      # Feign Client Configuration
      SERVICES_PATIENT_URL: http://patient-service:8081
      FEIGN_CLIENT_CONFIG_DEFAULT_CONNECT_TIMEOUT: 5000
      FEIGN_CLIENT_CONFIG_DEFAULT_READ_TIMEOUT: 10000
      # Logging Configuration
      LOGGING_LEVEL_DE_HIS_ENCOUNTER: DEBUG
      LOGGING_LEVEL_FEIGN: DEBUG
      LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_CLOUD_OPENFEIGN: DEBUG
      LOGGING_LEVEL_ORG_HIBERNATE_SQL: DEBUG
      LOGGING_LEVEL_ROOT: INFO
      # Application Configuration
      SERVER_PORT: 8082
      MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE: health,info,metrics
      MANAGEMENT_ENDPOINT_HEALTH_SHOW_DETAILS: always
    ports:
      - "8082:8082"
    networks:
      - his-network-minimal
    depends_on:
      postgres:
        condition: service_healthy
      patient-service:
        condition: service_healthy
    healthcheck:
      test:
        [
          "CMD",
          "wget",
          "--no-verbose",
          "--tries=1",
          "--spider",
          "http://localhost:8082/actuator/health",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    restart: unless-stopped
    volumes:
      - ./logs/encounter:/app/logs

  # API Gateway - Port 8080
  api-gateway:
    build:
      context: ./his-api-gateway
      dockerfile: Dockerfile
    container_name: his-api-gateway-minimal
    environment:
      # Patient Service Route
      SPRING_CLOUD_GATEWAY_ROUTES_0_ID: patient-service
      SPRING_CLOUD_GATEWAY_ROUTES_0_URI: http://patient-service:8081
      SPRING_CLOUD_GATEWAY_ROUTES_0_PREDICATES_0: Path=/api/v1/patients/**
      # Encounter Service Route
      SPRING_CLOUD_GATEWAY_ROUTES_1_ID: encounter-service
      SPRING_CLOUD_GATEWAY_ROUTES_1_URI: http://encounter-service:8082
      SPRING_CLOUD_GATEWAY_ROUTES_1_PREDICATES_0: Path=/api/v1/encounters/**
      # Patient Health Route
      SPRING_CLOUD_GATEWAY_ROUTES_2_ID: patient-health
      SPRING_CLOUD_GATEWAY_ROUTES_2_URI: http://patient-service:8081
      SPRING_CLOUD_GATEWAY_ROUTES_2_PREDICATES_0: Path=/services/patient/actuator/**
      SPRING_CLOUD_GATEWAY_ROUTES_2_FILTERS_0: StripPrefix=2
      # Encounter Health Route
      SPRING_CLOUD_GATEWAY_ROUTES_3_ID: encounter-health
      SPRING_CLOUD_GATEWAY_ROUTES_3_URI: http://encounter-service:8082
      SPRING_CLOUD_GATEWAY_ROUTES_3_PREDICATES_0: Path=/services/encounter/actuator/**
      SPRING_CLOUD_GATEWAY_ROUTES_3_FILTERS_0: StripPrefix=2
      # Patient Docs Route
      SPRING_CLOUD_GATEWAY_ROUTES_4_ID: patient-docs
      SPRING_CLOUD_GATEWAY_ROUTES_4_URI: http://patient-service:8081
      SPRING_CLOUD_GATEWAY_ROUTES_4_PREDICATES_0: Path=/docs/patient/**
      SPRING_CLOUD_GATEWAY_ROUTES_4_FILTERS_0: StripPrefix=2
      # Encounter Docs Route
      SPRING_CLOUD_GATEWAY_ROUTES_5_ID: encounter-docs
      SPRING_CLOUD_GATEWAY_ROUTES_5_URI: http://encounter-service:8082
      SPRING_CLOUD_GATEWAY_ROUTES_5_PREDICATES_0: Path=/docs/encounter/**
      SPRING_CLOUD_GATEWAY_ROUTES_5_FILTERS_0: StripPrefix=2
      # Redis Configuration - KORRIGIERT
      SPRING_REDIS_HOST: redis
      SPRING_REDIS_PORT: 6379
      SPRING_REDIS_TIMEOUT: 2000ms
      SPRING_DATA_REDIS_HOST: redis
      SPRING_DATA_REDIS_PORT: 6379
      # Profile Configuration
      SPRING_PROFILES_ACTIVE: docker-minimal
      # Logging Configuration
      LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_CLOUD_GATEWAY: DEBUG
      LOGGING_LEVEL_ROOT: INFO
      # Application Configuration
      SERVER_PORT: 8080
      MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE: health,info,metrics,gateway,circuitbreakers
      MANAGEMENT_ENDPOINT_HEALTH_SHOW_DETAILS: always
    ports:
      - "8080:8080"
    networks:
      - his-network-minimal
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      patient-service:
        condition: service_healthy
      encounter-service:
        condition: service_healthy
    healthcheck:
      test:
        [
          "CMD",
          "wget",
          "--no-verbose",
          "--tries=1",
          "--spider",
          "http://localhost:8080/actuator/health",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 90s
    restart: unless-stopped
    volumes:
      - ./logs/gateway:/app/logs

networks:
  his-network-minimal:
    driver: bridge
    name: his-network-minimal

volumes:
  postgres_data_minimal:
    name: his-postgres-data-minimal
  redis_data_minimal:
    name: his-redis-data-minimal

```

### File: ./docker-compose.dev.yml
```yaml
services:
  # Elasticsearch - Search and Analytics Engine
  elasticsearch:
    image: elasticsearch:8.11.0
    container_name: his-elasticsearch
    environment:
      - node.name=elasticsearch
      - cluster.name=his-cluster
      - discovery.type=single-node
      - bootstrap.memory_lock=true
      - "ES_JAVA_OPTS=-Xms1g -Xmx1g"
      - xpack.security.enabled=false
      - xpack.security.enrollment.enabled=false
      - cluster.routing.allocation.disk.threshold_enabled=false
    ulimits:
      memlock:
        soft: -1
        hard: -1
    volumes:
      - elasticsearch_data:/usr/share/elasticsearch/data
    ports:
      - "9200:9200"
      - "9300:9300"
    networks:
      - elk
    healthcheck:
      test:
        ["CMD-SHELL", "curl -f http://localhost:9200/_cluster/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5

  # Logstash - Log Processing Pipeline
  logstash:
    image: logstash:8.11.0
    container_name: his-logstash
    environment:
      - "LS_JAVA_OPTS=-Xmx512m -Xms512m"
    volumes:
      - ./elk-config/logstash/pipeline:/usr/share/logstash/pipeline:ro
      - ./elk-config/logstash/config/logstash.yml:/usr/share/logstash/config/logstash.yml:ro
      - ./logs:/usr/share/logstash/logs:ro
    ports:
      - "5044:5044"
      - "5001:5001/tcp" # Port 5000 ‚Üí 5001 (macOS Konflikt vermeiden)
      - "5001:5001/udp" # Port 5000 ‚Üí 5001 (macOS Konflikt vermeiden)
      - "9600:9600"
    networks:
      - elk
    depends_on:
      elasticsearch:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:9600 || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5

  # Kibana - Data Visualization
  kibana:
    image: kibana:8.11.0
    container_name: his-kibana
    environment:
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
      - ELASTICSEARCH_URL=http://elasticsearch:9200
      - server.host=0.0.0.0
      - server.shutdownTimeout=5s
      - logging.appenders.console.type=console
      - logging.appenders.console.layout.type=json
    volumes:
      - ./elk-config/kibana/kibana.yml:/usr/share/kibana/config/kibana.yml:ro
    ports:
      - "5601:5601"
    networks:
      - elk
    depends_on:
      elasticsearch:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:5601/api/status || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5

  # PostgreSQL Database
  postgres:
    image: postgres:15-alpine
    container_name: his-postgres-elk
    environment:
      POSTGRES_DB: his_db
      POSTGRES_USER: his_user
      POSTGRES_PASSWORD: dev_password
      POSTGRES_INITDB_ARGS: "--auth-host=scram-sha-256"
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-db.sql:/docker-entrypoint-initdb.d/init-db.sql
    networks:
      - his-network
      - elk
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U his_user -d his_db"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis for Rate Limiting and Caching
  redis:
    image: redis:7-alpine
    container_name: his-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - his-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    command: redis-server --appendonly yes

  # API Gateway - Central Entry Point
  api-gateway:
    build:
      context: ./his-api-gateway
      dockerfile: Dockerfile
    container_name: his-api-gateway
    environment:
      SPRING_PROFILES_ACTIVE: docker

      # JWT Configuration (disabled by default)
      JWT_ENABLED: "false"
      JWT_SECRET: "your-secret-key-change-in-production-make-it-longer-than-256-bits"

      # Rate Limiting (disabled by default)
      RATE_LIMIT_ENABLED: "false"
      REDIS_HOST: redis
      REDIS_PORT: 6379

      # Service URLs
      PATIENT_SERVICE_URL: "http://patient-service:8081"
      ENCOUNTER_SERVICE_URL: "http://encounter-service:8082"

      # ELK Integration
      LOGSTASH_HOST: logstash
      LOGSTASH_PORT: 5001 # Updated port
    ports:
      - "8080:8080" # Gateway runs on 8080 (external access)
    volumes:
      - ./logs/gateway:/app/logs
    networks:
      - his-network
      - elk
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      logstash:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 5
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
        labels: "service=api-gateway,environment=development"

  # Patient Service - Now on Port 8081
  patient-service:
    build:
      context: ./his-patient-service
      dockerfile: Dockerfile
    container_name: his-patient-service-elk
    environment:
      SPRING_PROFILES_ACTIVE: docker
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/his_patient
      SPRING_DATASOURCE_USERNAME: his_user
      SPRING_DATASOURCE_PASSWORD: dev_password
      SERVER_PORT: 8081 # Changed from 8080 to 8081

      # ELK Integration
      LOGSTASH_HOST: logstash
      LOGSTASH_PORT: 5001 # Updated port
    ports:
      - "8081:8081" # Direct access to Patient Service
    volumes:
      - ./logs/patient:/app/logs
    networks:
      - his-network
      - elk
    depends_on:
      postgres:
        condition: service_healthy
      logstash:
        condition: service_healthy
    healthcheck:
      test:
        [
          "CMD",
          "wget",
          "--no-verbose",
          "--tries=1",
          "--spider",
          "http://localhost:8081/actuator/health",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
        labels: "service=patient-service,environment=development"

  # Encounter Service - Now on Port 8082
  encounter-service:
    build:
      context: ./his-encounter-service
      dockerfile: Dockerfile
    container_name: his-encounter-service-elk
    environment:
      SPRING_PROFILES_ACTIVE: docker
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/his_encounter
      SPRING_DATASOURCE_USERNAME: his_user
      SPRING_DATASOURCE_PASSWORD: dev_password
      SERVER_PORT: 8082 # Changed from 8081 to 8082
      SERVICES_PATIENT_URL: http://patient-service:8081 # Updated Patient Service URL

      # ELK Integration
      LOGSTASH_HOST: logstash
      LOGSTASH_PORT: 5001 # Updated port
    ports:
      - "8082:8082" # Direct access to Encounter Service
    volumes:
      - ./logs/encounter:/app/logs
    networks:
      - his-network
      - elk
    depends_on:
      postgres:
        condition: service_healthy
      patient-service:
        condition: service_healthy
      logstash:
        condition: service_healthy
    healthcheck:
      test:
        [
          "CMD",
          "wget",
          "--no-verbose",
          "--tries=1",
          "--spider",
          "http://localhost:8082/actuator/health",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
        labels: "service=encounter-service,environment=development"

  # Filebeat - Log Shipper
  filebeat:
    image: elastic/filebeat:8.11.0
    container_name: his-filebeat
    user: root
    environment:
      - ELASTICSEARCH_HOST=elasticsearch:9200
      - LOGSTASH_HOST=logstash:5044
    volumes:
      - ./elk-config/filebeat/filebeat.yml:/usr/share/filebeat/filebeat.yml:ro
      - ./logs:/usr/share/filebeat/logs:ro
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - filebeat_data:/usr/share/filebeat/data
    networks:
      - elk
    depends_on:
      logstash:
        condition: service_healthy
    command: filebeat -e -strict.perms=false

volumes:
  elasticsearch_data:
    driver: local
  postgres_data:
    driver: local
  filebeat_data:
    driver: local
  redis_data:
    driver: local

networks:
  his-network:
    driver: bridge
  elk:
    driver: bridge

```

### File: ./complete-his-test.sh
```bash
#!/bin/bash

echo "üè• HIS SYSTEM - KOMPLETTER API TEST"
echo "===================================="

# Farben f√ºr Output
GREEN='\033[0;32m'
RED='\033[0;31m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

BASE_AUTH="Authorization: Basic $(echo -n 'admin:dev-password' | base64)"

# 1. SYSTEM HEALTH CHECK
echo -e "${BLUE}üîç 1. SYSTEM HEALTH CHECK${NC}"
echo "Checking all services..."

echo -n "API Gateway (8080): "
if curl -s http://localhost:8080/actuator/health | grep -q "UP"; then
    echo -e "${GREEN}‚úÖ UP${NC}"
else
    echo -e "${RED}‚ùå DOWN${NC}"
fi

echo -n "Patient Service (8081): "
if curl -s http://localhost:8081/actuator/health | grep -q "UP"; then
    echo -e "${GREEN}‚úÖ UP${NC}"
else
    echo -e "${RED}‚ùå DOWN${NC}"
fi

echo -n "Encounter Service (8082): "
if curl -s http://localhost:8082/actuator/health | grep -q "UP"; then
    echo -e "${GREEN}‚úÖ UP${NC}"
else
    echo -e "${RED}‚ùå DOWN${NC}"
fi

echo ""

# 2. PATIENT ANLEGEN - VOLLST√ÑNDIGER TEST
echo -e "${BLUE}üè• 2. PATIENT ANLEGEN (Alle Pflichtfelder)${NC}"

PATIENT_RESPONSE=$(curl -s -X POST "http://localhost:8081/api/v1/patients" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "$BASE_AUTH" \
  -d '{
    "kvnr": "T123456789",
    "firstName": "Max",
    "lastName": "Mustermann",
    "title": "Dr.",
    "birthDate": "1985-03-15",
    "gender": "MALE",
    "phone": "+49 30 12345678",
    "email": "max.mustermann@example.com",
    "insuranceNumber": "1234567890123",
    "insuranceType": "STATUTORY",
    "insuranceCompanyId": "101575519",
    "insuranceCompanyName": "AOK NORDOST - Die Gesundheitskasse",
    "insuranceStatus": "ACTIVE",
    "consentCommunication": true,
    "consentDataProcessing": true
  }')

if echo "$PATIENT_RESPONSE" | jq -e .id > /dev/null 2>&1; then
    echo -e "${GREEN}‚úÖ Patient erfolgreich angelegt!${NC}"
    echo "$PATIENT_RESPONSE" | jq
    
    # Extrahiere Patient ID
    PATIENT_ID=$(echo "$PATIENT_RESPONSE" | jq -r .id)
    echo -e "${YELLOW}üìã Patient ID: $PATIENT_ID${NC}"
else
    echo -e "${RED}‚ùå Patient anlegen fehlgeschlagen!${NC}"
    echo "$PATIENT_RESPONSE"
    exit 1
fi

echo ""

# 3. PATIENT ABRUFEN - VALIDIERUNG
echo -e "${BLUE}üîç 3. PATIENT ABRUFEN (Validierung)${NC}"

PATIENT_GET=$(curl -s -X GET "http://localhost:8081/api/v1/patients/$PATIENT_ID" \
  -H "Accept: application/json" \
  -H "$BASE_AUTH")

if echo "$PATIENT_GET" | jq -e .id > /dev/null 2>&1; then
    echo -e "${GREEN}‚úÖ Patient erfolgreich abgerufen!${NC}"
    echo "$PATIENT_GET" | jq
else
    echo -e "${RED}‚ùå Patient abrufen fehlgeschlagen!${NC}"
    echo "$PATIENT_GET"
fi

echo ""

# 4. ENCOUNTER ANLEGEN - VOLLST√ÑNDIGER TEST
echo -e "${BLUE}üìã 4. ENCOUNTER ANLEGEN (Alle Pflichtfelder)${NC}"

ENCOUNTER_RESPONSE=$(curl -s -X POST "http://localhost:8082/api/v1/encounters" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -H "$BASE_AUTH" \
  -d "{
    \"patientId\": \"$PATIENT_ID\",
    \"type\": \"OUTPATIENT\",
    \"status\": \"PLANNED\",
    \"reason\": \"Routineuntersuchung - Jahreschecku p\",
    \"scheduledStart\": \"2025-08-08T10:00:00\",
    \"scheduledEnd\": \"2025-08-08T11:00:00\",
    \"priority\": \"ROUTINE\",
    \"location\": \"Praxis Dr. Mustermann\",
    \"department\": \"Allgemeinmedizin\",
    \"practitioner\": \"Dr. Sarah Schmidt\",
    \"billingContext\": {
      \"insuranceType\": \"STATUTORY\",
      \"billingNumber\": \"12345678\",
      \"costCenter\": \"AMB-001\"
    },
    \"documentation\": [
      {
        \"type\": \"ANAMNESIS\",
        \"content\": \"Patient berichtet √ºber gelegentliche Kopfschmerzen\",
        \"authorId\": \"dr-schmidt\",
        \"timestamp\": \"2025-08-08T10:15:00\"
      }
    ]
  }")

if echo "$ENCOUNTER_RESPONSE" | jq -e .id > /dev/null 2>&1; then
    echo -e "${GREEN}‚úÖ Encounter erfolgreich angelegt!${NC}"
    echo "$ENCOUNTER_RESPONSE" | jq
    
    # Extrahiere Encounter ID
    ENCOUNTER_ID=$(echo "$ENCOUNTER_RESPONSE" | jq -r .id)
    echo -e "${YELLOW}üìã Encounter ID: $ENCOUNTER_ID${NC}"
else
    echo -e "${RED}‚ùå Encounter anlegen fehlgeschlagen!${NC}"
    echo "$ENCOUNTER_RESPONSE"
fi

echo ""

# 5. PATIENT SUCHE TESTEN
echo -e "${BLUE}üîç 5. PATIENT SUCHE TESTEN${NC}"

SEARCH_RESPONSE=$(curl -s -X GET "http://localhost:8081/api/v1/patients/search?searchTerm=Mustermann&page=0&size=10" \
  -H "Accept: application/json" \
  -H "$BASE_AUTH")

if echo "$SEARCH_RESPONSE" | jq -e .content > /dev/null 2>&1; then
    echo -e "${GREEN}‚úÖ Patient Suche erfolgreich!${NC}"
    FOUND_COUNT=$(echo "$SEARCH_RESPONSE" | jq '.content | length')
    echo -e "${YELLOW}üìä Gefundene Patienten: $FOUND_COUNT${NC}"
    echo "$SEARCH_RESPONSE" | jq '.content[] | {id, fullName, kvnr}'
else
    echo -e "${RED}‚ùå Patient Suche fehlgeschlagen!${NC}"
    echo "$SEARCH_RESPONSE"
fi

echo ""

# 6. PATIENT √úBER KVNR ABRUFEN
echo -e "${BLUE}üîç 6. PATIENT √úBER KVNR ABRUFEN${NC}"

KVNR_RESPONSE=$(curl -s -X GET "http://localhost:8081/api/v1/patients/kvnr/T123456789" \
  -H "Accept: application/json" \
  -H "$BASE_AUTH")

if echo "$KVNR_RESPONSE" | jq -e .id > /dev/null 2>&1; then
    echo -e "${GREEN}‚úÖ Patient √ºber KVNR erfolgreich gefunden!${NC}"
    echo "$KVNR_RESPONSE" | jq '{id, fullName, kvnr, insuranceStatus}'
else
    echo -e "${RED}‚ùå Patient √ºber KVNR nicht gefunden!${NC}"
    echo "$KVNR_RESPONSE"
fi

echo ""

# 7. API GATEWAY ROUTING TESTEN
echo -e "${BLUE}üåê 7. API GATEWAY ROUTING TESTEN${NC}"

echo "Testing Patient Service via API Gateway..."
GATEWAY_PATIENT=$(curl -s -X GET "http://localhost:8080/api/v1/patients/$PATIENT_ID" \
  -H "Accept: application/json" \
  -H "$BASE_AUTH")

if echo "$GATEWAY_PATIENT" | jq -e .id > /dev/null 2>&1; then
    echo -e "${GREEN}‚úÖ API Gateway ‚Üí Patient Service routing funktioniert!${NC}"
else
    echo -e "${RED}‚ùå API Gateway ‚Üí Patient Service routing fehlgeschlagen!${NC}"
fi

echo "Testing Encounter Service via API Gateway..."
GATEWAY_ENCOUNTER=$(curl -s -X GET "http://localhost:8080/api/v1/encounters/$ENCOUNTER_ID" \
  -H "Accept: application/json" \
  -H "$BASE_AUTH" 2>/dev/null || echo '{"error":"not implemented"}')

if echo "$GATEWAY_ENCOUNTER" | jq -e .id > /dev/null 2>&1; then
    echo -e "${GREEN}‚úÖ API Gateway ‚Üí Encounter Service routing funktioniert!${NC}"
else
    echo -e "${YELLOW}‚ö†Ô∏è API Gateway ‚Üí Encounter Service routing nicht konfiguriert oder Endpoint nicht implementiert${NC}"
fi

echo ""

# 8. FEIGN CLIENT TEST (Service-zu-Service Kommunikation)
echo -e "${BLUE}üîó 8. FEIGN CLIENT TEST (Service-zu-Service)${NC}"

if [[ "$ENCOUNTER_RESPONSE" == *"$PATIENT_ID"* ]]; then
    echo -e "${GREEN}‚úÖ Feign Client: Encounter Service kann Patient Service erreichen!${NC}"
    echo -e "${YELLOW}üìã Patient ID wurde erfolgreich im Encounter referenziert${NC}"
else
    echo -e "${RED}‚ùå Feign Client Problem: Patient Referenz nicht korrekt${NC}"
fi

echo ""

# 9. ZUSAMMENFASSUNG
echo -e "${BLUE}üìä 9. TEST ZUSAMMENFASSUNG${NC}"
echo "=========================================="
echo -e "${GREEN}‚úÖ ERFOLGREICH GETESTET:${NC}"
echo "   ‚Ä¢ Patient Service: CREATE, READ, SEARCH, KVNR-Lookup"
echo "   ‚Ä¢ Encounter Service: CREATE mit Patient-Referenz"  
echo "   ‚Ä¢ API Gateway: Routing zu Services"
echo "   ‚Ä¢ Database: PostgreSQL + Flyway Migrationen"
echo "   ‚Ä¢ Service Communication: Feign Client"
echo ""
echo -e "${YELLOW}üìã ERSTELLTE DATEN:${NC}"
echo "   ‚Ä¢ Patient: $PATIENT_ID (KVNR: T123456789)"
echo "   ‚Ä¢ Encounter: $ENCOUNTER_ID"
echo ""
echo -e "${GREEN}üéâ HIS SYSTEM VOLLST√ÑNDIG FUNKTIONSF√ÑHIG!${NC}"
echo ""
echo -e "${BLUE}üîó N√úTZLICHE ENDPOINTS:${NC}"
echo "   ‚Ä¢ Patient Service: http://localhost:8081"
echo "   ‚Ä¢ Encounter Service: http://localhost:8082"  
echo "   ‚Ä¢ API Gateway: http://localhost:8080"
echo "   ‚Ä¢ Swagger UI (Patient): http://localhost:8081/swagger-ui/index.html"
echo "   ‚Ä¢ Swagger UI (Encounter): http://localhost:8082/swagger-ui/index.html"
```

### File: ./create-patients.sh
```bash
#!/bin/bash
echo "üë• Creating realistic test patients with valid KVNRs..."

# Deutsche Krankenkassen Array
declare -a insurance_companies=(
    "AOK Bayern"
    "Techniker Krankenkasse" 
    "Barmer"
    "DAK-Gesundheit"
    "IKK classic"
    "Debeka"
    "HUK-COBURG"
    "Signal Iduna"
)

# Realistische Namen Arrays
declare -a male_names=("Max" "Alexander" "Thomas" "Michael" "Christian" "Andreas" "Stefan" "Markus")
declare -a female_names=("Anna" "Maria" "Sandra" "Julia" "Petra" "Sabine" "Andrea" "Nicole")
declare -a surnames=("M√ºller" "Schmidt" "Schneider" "Fischer" "Weber" "Meyer" "Wagner" "Becker")

create_realistic_patient() {
    local index=$1
    local gender=$2
    
    # Name selection based on gender
    if [ "$gender" = "MALE" ]; then
        local first_name=${male_names[$((index % ${#male_names[@]}))]}
        local kvnr_prefix="M"
    else
        local first_name=${female_names[$((index % ${#female_names[@]}))]}
        local kvnr_prefix="A"
    fi
    
    local last_name=${surnames[$((index % ${#surnames[@]}))]}
    local insurance=${insurance_companies[$((index % ${#insurance_companies[@]}))]}
    
    # Generate realistic birth date (20-80 years old)
    local birth_year=$((1945 + RANDOM % 60))
    local birth_month=$(printf "%02d" $((1 + RANDOM % 12)))
    local birth_day=$(printf "%02d" $((1 + RANDOM % 28)))
    local birth_date="${birth_year}-${birth_month}-${birth_day}"
    
    # Generate KVNR with birth data
    local year_suffix=${birth_year: -2}
    local kvnr="${kvnr_prefix}${year_suffix}${birth_month}${birth_day}$(printf "%02d" $index)$(( (index * 7) % 10 ))"
    
    # Insurance type based on company
    local insurance_type="STATUTORY"
    if [[ "$insurance" == "Debeka" || "$insurance" == "HUK-COBURG" || "$insurance" == "Signal Iduna" ]]; then
        insurance_type="PRIVATE"
    fi
    
    echo "Creating: $first_name $last_name ($gender, $birth_date, $kvnr)"
    
    curl -s -X POST http://localhost:8080/api/v1/patients \
        -H "Content-Type: application/json" \
        -H "Authorization: Basic $(echo -n 'admin:dev-password' | base64)" \
        -d "{
            \"firstName\": \"$first_name\",
            \"lastName\": \"$last_name\", 
            \"birthDate\": \"$birth_date\",
            \"gender\": \"$gender\",
            \"kvnr\": \"$kvnr\",
            \"insuranceType\": \"$insurance_type\",
            \"insuranceCompanyName\": \"$insurance\",
            \"phone\": \"+49 $((100 + RANDOM % 900)) $((1000000 + RANDOM % 9000000))\",
            \"email\": \"$(echo $first_name | tr '[:upper:]' '[:lower:]').$(echo $last_name | tr '[:upper:]' '[:lower:]')@example.com\",
            \"consentCommunication\": $([[ $((RANDOM % 2)) -eq 0 ]] && echo true || echo false),
            \"consentDataProcessing\": true
        }" | jq '{id, firstName, lastName, kvnr, insuranceType, insuranceCompanyName}' 2>/dev/null
    
    echo ""
}

# Create 10 realistic patients
for i in {1..10}; do
    if [ $((i % 2)) -eq 0 ]; then
        create_realistic_patient $i "FEMALE"
    else 
        create_realistic_patient $i "MALE"
    fi
    sleep 1  # Rate limiting
done

echo "‚úÖ Realistic test data creation completed!"
```

### File: ./debug.sh
```bash
#!/bin/bash

# Korrekte API-Calls basierend auf dem tats√§chlichen Projektwissen
# WICHTIG: Encounter List API existiert NICHT - nur Patient-spezifische Calls

AUTH_HEADER="Authorization: Basic $(echo -n 'admin:dev-password' | base64)"

echo "üîß Korrekte Frontend API-Calls (Projektwissen-basiert)"
echo "====================================================="

# =================================================================
# 1. BACKEND-LOGS ANALYSIEREN (Patient Service HTTP 500 Problem)
# =================================================================

echo ""
echo "1Ô∏è‚É£ Backend-Logs analysieren"
echo "---------------------------"

echo "Patient Service Logs (letzten 50 Zeilen):"
docker-compose -f docker-compose-minimal.yml logs his-patient-service-minimal --tail=50 | grep -i "error\|exception\|stack" || echo "Keine Error-Logs sichtbar"

echo ""
echo "Encounter Service Logs (letzten 50 Zeilen):"
docker-compose -f docker-compose-minimal.yml logs his-encounter-service-minimal --tail=50 | grep -i "error\|exception\|stack" || echo "Keine Error-Logs sichtbar"

echo ""
echo "API Gateway Logs (letzten 50 Zeilen):"
docker-compose -f docker-compose-minimal.yml logs his-api-gateway-minimal --tail=50 | grep -i "error\|exception\|stack" || echo "Keine Error-Logs sichtbar"

# =================================================================
# 2. KORREKTE ENCOUNTER API ENDPUNKTE (aus Projektwissen)
# =================================================================

echo ""
echo "2Ô∏è‚É£ Korrekte Encounter API Endpunkte"
echo "-----------------------------------"

echo "‚ùå FALSCH: GET /api/v1/encounters (existiert nicht!)"
echo "‚úÖ RICHTIG: Laut Projektwissen gibt es nur:"
echo "   ‚Ä¢ POST /api/v1/encounters - Encounter erstellen"
echo "   ‚Ä¢ GET /api/v1/encounters/{id} - Einzelner Encounter" 
echo "   ‚Ä¢ GET /api/v1/encounters/patient/{patientId} - Patient-Encounters"

# Test Patient Service Health (direkter Zugriff)
echo ""
echo "Testing Patient Service Health (direkt):"
PATIENT_HEALTH=$(curl -s http://localhost:8081/actuator/health 2>/dev/null)
echo "Patient Service Health: $(echo "$PATIENT_HEALTH" | jq -r '.status // "ERROR"' 2>/dev/null || echo "ERROR")"

# Test Encounter Service Health (direkter Zugriff)
echo ""
echo "Testing Encounter Service Health (direkt):"
ENCOUNTER_HEALTH=$(curl -s http://localhost:8082/actuator/health 2>/dev/null)
echo "Encounter Service Health: $(echo "$ENCOUNTER_HEALTH" | jq -r '.status // "ERROR"' 2>/dev/null || echo "ERROR")"

# =================================================================
# 3. SWAGGER UI √úBERPR√úFUNG (Verf√ºgbare Endpunkte anzeigen)
# =================================================================

echo ""
echo "3Ô∏è‚É£ Swagger UI √úberpr√ºfung"
echo "-------------------------"

echo "Patient Service Swagger UI:"
echo "  URL: http://localhost:8081/swagger-ui.html"
SWAGGER_PATIENT=$(curl -s http://localhost:8081/swagger-ui.html 2>/dev/null | head -c 100)
if [[ "$SWAGGER_PATIENT" == *"swagger"* ]] || [[ "$SWAGGER_PATIENT" == *"Swagger"* ]]; then
    echo "  ‚úÖ Swagger UI erreichbar"
else
    echo "  ‚ùå Swagger UI nicht erreichbar"
fi

echo ""
echo "Encounter Service Swagger UI:"
echo "  URL: http://localhost:8082/swagger-ui.html" 
SWAGGER_ENCOUNTER=$(curl -s http://localhost:8082/swagger-ui.html 2>/dev/null | head -c 100)
if [[ "$SWAGGER_ENCOUNTER" == *"swagger"* ]] || [[ "$SWAGGER_ENCOUNTER" == *"Swagger"* ]]; then
    echo "  ‚úÖ Swagger UI erreichbar"
else
    echo "  ‚ùå Swagger UI nicht erreichbar"
fi

# =================================================================
# 4. PATIENT SERVICE DEBUGGING (HTTP 500 Problem l√∂sen)
# =================================================================

echo ""
echo "4Ô∏è‚É£ Patient Service Debugging"
echo "----------------------------"

# Test verschiedene Patient Endpunkte
echo "Testing Patient Actuator Health:"
curl -s -w "HTTP_%{http_code} " http://localhost:8081/actuator/health 2>/dev/null | head -c 200
echo ""

echo ""
echo "Testing Patient Actuator Info:"
curl -s -w "HTTP_%{http_code} " http://localhost:8081/actuator/info 2>/dev/null | head -c 200
echo ""

echo ""
echo "Testing Patient API Root:"
curl -s -w "HTTP_%{http_code} " -H "$AUTH_HEADER" http://localhost:8081/api/v1/patients 2>/dev/null | head -c 200
echo ""

echo ""
echo "Testing Patient API via Gateway:"
curl -s -w "HTTP_%{http_code} " -H "$AUTH_HEADER" http://localhost:8080/api/v1/patients 2>/dev/null | head -c 200
echo ""

# =================================================================
# 5. WORKING PATIENT CREATION (Um Daten f√ºr Encounter zu haben)
# =================================================================

echo ""
echo "5Ô∏è‚É£ Patient Creation Test"
echo "------------------------"

# Generate unique KVNR (1 Buchstabe + 9 Ziffern)
UNIQUE_KVNR="T$(printf "%09d" $(($(date +%s) % 1000000000)))"
echo "Trying to create patient with KVNR: $UNIQUE_KVNR"

PATIENT_CREATION=$(curl -s -w "HTTPSTATUS:%{http_code}" \
  -X POST http://localhost:8080/api/v1/patients \
  -H "Content-Type: application/json" \
  -H "$AUTH_HEADER" \
  -d "{
    \"firstName\": \"Debug\",
    \"lastName\": \"Patient\",
    \"birthDate\": \"1990-01-01\",
    \"gender\": \"MALE\",
    \"kvnr\": \"$UNIQUE_KVNR\",
    \"insuranceType\": \"STATUTORY\"
  }")

PATIENT_BODY=$(echo "$PATIENT_CREATION" | sed -E 's/HTTPSTATUS:[0-9]{3}$//')
PATIENT_STATUS=$(echo "$PATIENT_CREATION" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)

echo "Patient Creation Status: $PATIENT_STATUS"

if [ "$PATIENT_STATUS" = "201" ]; then
    echo "‚úÖ Patient created successfully!"
    PATIENT_ID=$(echo "$PATIENT_BODY" | jq -r '.id')
    echo "Patient ID: $PATIENT_ID"
else
    echo "‚ùå Patient creation failed:"
    echo "$PATIENT_BODY" | jq '.' 2>/dev/null || echo "$PATIENT_BODY"
fi

# =================================================================
# 6. KORREKTE ENCOUNTER APIS (basierend auf Projektwissen)
# =================================================================

echo ""
echo "6Ô∏è‚É£ Korrekte Encounter APIs testen"
echo "---------------------------------"

if [ -n "$PATIENT_ID" ] && [ "$PATIENT_ID" != "null" ]; then
    echo "Testing Encounter Creation for Patient: $PATIENT_ID"
    
    # Encounter erstellen (korrekte API laut Projektwissen)
    PRACTITIONER_ID=$(uuidgen | tr '[:upper:]' '[:lower:]')
    
    ENCOUNTER_CREATION=$(curl -s -w "HTTPSTATUS:%{http_code}" \
      -X POST http://localhost:8080/api/v1/encounters \
      -H "Content-Type: application/json" \
      -H "$AUTH_HEADER" \
      -d "{
        \"patientId\": \"$PATIENT_ID\",
        \"practitionerId\": \"$PRACTITIONER_ID\",
        \"type\": \"INITIAL\",
        \"encounterDate\": \"$(date -u +%Y-%m-%dT%H:%M:%S)\",
        \"billingContext\": \"GKV\"
      }")
    
    ENCOUNTER_BODY=$(echo "$ENCOUNTER_CREATION" | sed -E 's/HTTPSTATUS:[0-9]{3}$//')
    ENCOUNTER_STATUS=$(echo "$ENCOUNTER_CREATION" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
    
    echo "Encounter Creation Status: $ENCOUNTER_STATUS"
    
    if [ "$ENCOUNTER_STATUS" = "201" ]; then
        echo "‚úÖ Encounter created successfully!"
        ENCOUNTER_ID=$(echo "$ENCOUNTER_BODY" | jq -r '.id')
        echo "Encounter ID: $ENCOUNTER_ID"
        
        # Test GET einzelner Encounter (korrekte API)
        echo ""
        echo "Testing GET single encounter:"
        curl -s -w "HTTP_%{http_code} " -H "$AUTH_HEADER" \
          http://localhost:8080/api/v1/encounters/$ENCOUNTER_ID | head -c 200
        echo ""
        
        # Test GET Patient-Encounters (korrekte API)
        echo ""
        echo "Testing GET patient encounters:"
        curl -s -w "HTTP_%{http_code} " -H "$AUTH_HEADER" \
          http://localhost:8080/api/v1/encounters/patient/$PATIENT_ID | head -c 200
        echo ""
        
    else
        echo "‚ùå Encounter creation failed:"
        echo "$ENCOUNTER_BODY" | jq '.' 2>/dev/null || echo "$ENCOUNTER_BODY"
    fi
else
    echo "‚ö†Ô∏è No Patient ID available for Encounter testing"
fi

# =================================================================
# 7. FRONTEND-KORREKTE API CALLS
# =================================================================

echo ""
echo "7Ô∏è‚É£ Frontend-korrekte API Calls"
echo "------------------------------"

echo "F√ºr React Frontend verwenden Sie:"
echo ""

echo "‚úÖ Patient List (FIXED):"
echo "   Aktuell: 500 Error - Backend-Problem"
echo "   Korrekt: GET /api/v1/patients"
echo "   curl -H \"$AUTH_HEADER\" http://localhost:8080/api/v1/patients"

echo ""
echo "‚úÖ Patient Search (FIXED):"
echo "   Aktuell: 500 Error - Backend-Problem" 
echo "   Korrekt: GET /api/v1/patients?q=searchterm"
echo "   curl -H \"$AUTH_HEADER\" 'http://localhost:8080/api/v1/patients?q=Max'"

echo ""
echo "‚ùå Encounter List (NICHT IMPLEMENTIERT):"
echo "   Falsch: GET /api/v1/encounters (existiert nicht)"
echo "   Alternative: GET /api/v1/encounters/patient/{patientId}"

echo ""
echo "‚úÖ Patient-Encounters (KORREKT):"
echo "   curl -H \"$AUTH_HEADER\" http://localhost:8080/api/v1/encounters/patient/{patientId}"

echo ""
echo "‚úÖ Single Encounter (KORREKT):"
echo "   curl -H \"$AUTH_HEADER\" http://localhost:8080/api/v1/encounters/{encounterId}"

echo ""
echo "‚úÖ Encounter Actions (KORREKT):"
echo "   Start: PUT /api/v1/encounters/{id}/start"
echo "   Complete: PUT /api/v1/encounters/{id}/complete"

# =================================================================
# 8. FRONTEND DASHBOARD WORKAROUND
# =================================================================

echo ""
echo "8Ô∏è‚É£ Frontend Dashboard Workaround"
echo "--------------------------------"

echo "Da GET /api/v1/encounters nicht existiert, muss das Frontend:"
echo ""
echo "1. Alle Patienten laden: GET /api/v1/patients"
echo "2. F√ºr jeden Patient Encounters laden: GET /api/v1/encounters/patient/{patientId}"
echo "3. Client-seitig aggregieren f√ºr Dashboard-Statistiken"

echo ""
echo "React Frontend Code-Beispiel:"
cat << 'EOF'
// Frontend Workaround f√ºr Encounter List
const loadAllEncounters = async () => {
  const patients = await fetch('/api/v1/patients');
  const allEncounters = [];
  
  for (const patient of patients) {
    const encounters = await fetch(`/api/v1/encounters/patient/${patient.id}`);
    allEncounters.push(...encounters);
  }
  
  return allEncounters;
};
EOF

# =================================================================
# ZUSAMMENFASSUNG
# =================================================================

echo ""
echo "=================================================="
echo "üéØ FRONTEND INTEGRATION SUMMARY"
echo "=================================================="
echo ""
echo "üö® BACKEND PROBLEME:"
echo "  1. Patient Service: HTTP 500 (Internal Server Error)"
echo "  2. Encounter List API: Existiert nicht (nur patient-spezifisch)"
echo ""
echo "‚úÖ VERF√úGBARE APIS:"
echo "  ‚Ä¢ Patient CREATE: POST /api/v1/patients"
echo "  ‚Ä¢ Patient GET: GET /api/v1/patients (aktuell 500 Error)"
echo "  ‚Ä¢ Patient Search: GET /api/v1/patients?q=term (aktuell 500 Error)"
echo "  ‚Ä¢ Encounter CREATE: POST /api/v1/encounters"
echo "  ‚Ä¢ Encounter GET: GET /api/v1/encounters/{id}"
echo "  ‚Ä¢ Patient Encounters: GET /api/v1/encounters/patient/{patientId}"
echo ""
echo "üîß NEXT STEPS:"
echo "  1. Patient Service HTTP 500 Problem l√∂sen"
echo "  2. Frontend anpassen f√ºr patient-spezifische Encounter-Calls"
echo "  3. Dashboard client-seitig aggregieren"
echo ""
echo "üìã REACT FRONTEND ANPASSUNGEN ERFORDERLICH:"
echo "  ‚Ä¢ Encounter List durch Patient-spezifische Calls ersetzen"
echo "  ‚Ä¢ Dashboard-Statistiken client-seitig berechnen"
echo "  ‚Ä¢ Error-Handling f√ºr Patient Service verbessern"
```

### File: ./extract-source-files Kopie.sh
```bash
# In das Projekt-Root-Verzeichnis wechseln (wo his-encounter-service/, his-patient-service/, his-api-gateway/ liegen)
cd his-project  # oder wie auch immer dein Root-Verzeichnis hei√üt

# Sources Verzeichnis erstellen/leeren
echo "Preparing Sources directory..."
if [ -d "Sources" ]; then
    rm -rf Sources/*
else
    mkdir Sources
fi

# Funktion f√ºr Service-Extraktion
extract_service() {
    local service_name=$1
    local service_dir=$2
    local output_file="${service_name}-source.txt"
    
    echo "Extracting ${service_name}..."
    
    # In Service-Verzeichnis wechseln
    cd "$service_dir"
    
    # Output-File erstellen
    echo "# HIS ${service_name} - Complete Source Code Structure" > "$output_file"
    echo "Generated: $(date)" >> "$output_file"
    echo "Project: Hospital Information System (HIS) - ${service_name}" >> "$output_file"
    echo "=========================================================" >> "$output_file"
    echo "" >> "$output_file"
    
    # Verzeichnisstruktur anzeigen (ohne Backups)
    echo "## Directory Structure" >> "$output_file"
    echo "\`\`\`" >> "$output_file"
    find . -type f -name "*.java" -o -name "*.yml" -o -name "*.yaml" -o -name "*.properties" -o -name "*.xml" -o -name "*.sql" -o -name "Dockerfile" -o -name "*.md" | grep -v target/ | grep -v .git/ | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | sort >> "$output_file"
    echo "\`\`\`" >> "$output_file"
    echo "" >> "$output_file"
    
    # Tree-Struktur
    echo "## Tree Structure" >> "$output_file"
    echo "\`\`\`" >> "$output_file"
    if command -v tree >/dev/null 2>&1; then
        tree -I 'target|.git|*.class|*.jar|backup*|*.bak|*.backup|*~' >> "$output_file"
    else
        echo "tree command not available - using find alternative:" >> "$output_file"
        find . -type d | grep -v target/ | grep -v .git/ | grep -v backup | sort | sed 's/[^/]*\//|  /g; s/|  \([^|]\)/+--\1/' >> "$output_file"
    fi
    echo "\`\`\`" >> "$output_file"
    echo "" >> "$output_file"
    
    # Source Code Files
    echo "## Source Code Files" >> "$output_file"
    echo "" >> "$output_file"
    
    # Java Files
    find . -name "*.java" | grep -v target/ | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | sort | while read file; do
        echo "### File: $file" >> "$output_file"
        echo "\`\`\`java" >> "$output_file"
        cat "$file" >> "$output_file"
        echo "" >> "$output_file"
        echo "\`\`\`" >> "$output_file"
        echo "" >> "$output_file"
    done
    
    # Configuration Files
    for ext in yml yaml properties; do
        find . -name "*.$ext" | grep -v target/ | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | sort | while read file; do
            echo "### File: $file" >> "$output_file"
            echo "\`\`\`$ext" >> "$output_file"
            cat "$file" >> "$output_file"
            echo "" >> "$output_file"
            echo "\`\`\`" >> "$output_file"
            echo "" >> "$output_file"
        done
    done
    
    # XML Files
    find . -name "*.xml" | grep -v target/ | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | sort | while read file; do
        echo "### File: $file" >> "$output_file"
        echo "\`\`\`xml" >> "$output_file"
        cat "$file" >> "$output_file"
        echo "" >> "$output_file"
        echo "\`\`\`" >> "$output_file"
        echo "" >> "$output_file"
    done
    
    # SQL Files
    find . -name "*.sql" | grep -v target/ | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | sort | while read file; do
        echo "### File: $file" >> "$output_file"
        echo "\`\`\`sql" >> "$output_file"
        cat "$file" >> "$output_file"
        echo "" >> "$output_file"
        echo "\`\`\`" >> "$output_file"
        echo "" >> "$output_file"
    done
    
    # Dockerfile
    if [ -f "Dockerfile" ] && ! echo "Dockerfile" | grep -q -E "(backup|\.bak|\.backup|~$)"; then
        echo "### File: ./Dockerfile" >> "$output_file"
        echo "\`\`\`dockerfile" >> "$output_file"
        cat Dockerfile >> "$output_file"
        echo "" >> "$output_file"
        echo "\`\`\`" >> "$output_file"
        echo "" >> "$output_file"
    fi
    
    # Markdown Files
    find . -name "*.md" | grep -v target/ | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | sort | while read file; do
        echo "### File: $file" >> "$output_file"
        echo "\`\`\`markdown" >> "$output_file"
        cat "$file" >> "$output_file"
        echo "" >> "$output_file"
        echo "\`\`\`" >> "$output_file"
        echo "" >> "$output_file"
    done
    
    # File in Sources Verzeichnis kopieren
    cp "$output_file" "../Sources/"
    
    # Zur√ºck zum Root-Verzeichnis
    cd ..
    
    echo "${service_name} extraction completed: Sources/${output_file}"
}

# Root Directory Files extrahieren
extract_root_files() {
    echo "Extracting Root Directory files..."
    
    local output_file="his-project-root-source.txt"
    
    # Output-File erstellen
    echo "# HIS Project Root - Configuration and Infrastructure Files" > "$output_file"
    echo "Generated: $(date)" >> "$output_file"
    echo "Project: Hospital Information System (HIS) - Root Directory" >> "$output_file"
    echo "=========================================================" >> "$output_file"
    echo "" >> "$output_file"
    
    # Root Directory Structure
    echo "## Root Directory Structure" >> "$output_file"
    echo "\`\`\`" >> "$output_file"
    find . -maxdepth 2 -type f -name "*.yml" -o -name "*.yaml" -o -name "*.md" -o -name "*.txt" -o -name "*.json" -o -name "*.xml" -o -name "*.properties" -o -name "Dockerfile" -o -name "*.sh" | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | grep -v "/target/" | grep -v "Sources/" | sort >> "$output_file"
    echo "\`\`\`" >> "$output_file"
    echo "" >> "$output_file"
    
    # Services Overview
    echo "## Available Services" >> "$output_file"
    echo "\`\`\`" >> "$output_file"
    ls -la | grep "^d" | grep -E "(his-|init-)" >> "$output_file"
    echo "\`\`\`" >> "$output_file"
    echo "" >> "$output_file"
    
    # Root Configuration Files
    echo "## Root Configuration Files" >> "$output_file"
    echo "" >> "$output_file"
    
    # Docker Compose Files
    for file in docker-compose*.yml docker-compose*.yaml; do
        if [ -f "$file" ] && ! echo "$file" | grep -q -E "(backup|\.bak|\.backup|~$)"; then
            echo "### File: ./$file" >> "$output_file"
            echo "\`\`\`yaml" >> "$output_file"
            cat "$file" >> "$output_file"
            echo "" >> "$output_file"
            echo "\`\`\`" >> "$output_file"
            echo "" >> "$output_file"
        fi
    done
    
    # README Files
    for file in README*.md readme*.md; do
        if [ -f "$file" ] && ! echo "$file" | grep -q -E "(backup|\.bak|\.backup|~$)"; then
            echo "### File: ./$file" >> "$output_file"
            echo "\`\`\`markdown" >> "$output_file"
            cat "$file" >> "$output_file"
            echo "" >> "$output_file"
            echo "\`\`\`" >> "$output_file"
            echo "" >> "$output_file"
        fi
    done
    
    # Other Configuration Files
    for file in *.json *.xml *.properties *.txt; do
        if [ -f "$file" ] && ! echo "$file" | grep -q -E "(backup|\.bak|\.backup|~$)" && ! echo "$file" | grep -q "source\.txt$"; then
            echo "### File: ./$file" >> "$output_file"
            echo "\`\`\`" >> "$output_file"
            cat "$file" >> "$output_file"
            echo "" >> "$output_file"
            echo "\`\`\`" >> "$output_file"
            echo "" >> "$output_file"
        fi
    done
    
    # Shell Scripts
    for file in *.sh; do
        if [ -f "$file" ] && ! echo "$file" | grep -q -E "(backup|\.bak|\.backup|~$)"; then
            echo "### File: ./$file" >> "$output_file"
            echo "\`\`\`bash" >> "$output_file"
            cat "$file" >> "$output_file"
            echo "" >> "$output_file"
            echo "\`\`\`" >> "$output_file"
            echo "" >> "$output_file"
        fi
    done
    
    # File in Sources Verzeichnis kopieren
    cp "$output_file" "Sources/"
    
    echo "Root directory extraction completed: Sources/$output_file"
}

# Hauptausf√ºhrung
echo "Starting HIS Project Source Code Extraction..."
echo "=============================================="

# Root Files extrahieren
extract_root_files

# Init Scripts als separater Service extrahieren
if [ -d "init-scripts" ]; then
    extract_service "Init Scripts" "init-scripts"
else
    echo "Warning: init-scripts directory not found"
fi

# Services extrahieren (pr√ºfen ob Verzeichnisse existieren)
if [ -d "his-encounter-service" ]; then
    extract_service "Encounter Service" "his-encounter-service"
else
    echo "Warning: his-encounter-service directory not found"
fi

if [ -d "his-patient-service" ]; then
    extract_service "Patient Service" "his-patient-service"
else
    echo "Warning: his-patient-service directory not found"
fi

if [ -d "his-api-gateway" ]; then
    extract_service "API Gateway" "his-api-gateway"
else
    echo "Warning: his-api-gateway directory not found"
fi

# Zusammenfassung erstellen
echo ""
echo "Creating extraction summary..."
summary_file="Sources/00-extraction-summary.txt"
echo "HIS Project Source Code Extraction Summary" > "$summary_file"
echo "Generated: $(date)" >> "$summary_file"
echo "==========================================" >> "$summary_file"
echo "" >> "$summary_file"
echo "Extracted Files:" >> "$summary_file"
ls -la Sources/ >> "$summary_file"
echo "" >> "$summary_file"
echo "File Sizes:" >> "$summary_file"
du -h Sources/* >> "$summary_file"

echo ""
echo "=============================================="
echo "Extraction Summary:"
echo "- All files are now available in: ./Sources/"
echo "- Root Directory: Sources/his-project-root-source.txt"
if [ -d "init-scripts" ]; then
    echo "- Init Scripts: Sources/Init Scripts-source.txt"
fi
if [ -d "his-encounter-service" ]; then
    echo "- Encounter Service: Sources/Encounter Service-source.txt"
fi
if [ -d "his-patient-service" ]; then
    echo "- Patient Service: Sources/Patient Service-source.txt"
fi
if [ -d "his-api-gateway" ]; then
    echo "- API Gateway: Sources/API Gateway-source.txt"
fi
echo "- Summary: Sources/00-extraction-summary.txt"
echo ""
echo "All source code extractions completed and copied to Sources directory!"
```

### File: ./extract-source-files.sh
```bash
# In das Projekt-Root-Verzeichnis wechseln (wo his-encounter-service/, his-patient-service/, his-api-gateway/, his-frontend/ liegen)
cd his-project  # oder wie auch immer dein Root-Verzeichnis hei√üt

# Sources Verzeichnis erstellen/leeren
echo "Preparing Sources directory..."
if [ -d "Sources" ]; then
    rm -rf Sources/*
else
    mkdir Sources
fi

# Funktion f√ºr Service-Extraktion
extract_service() {
    local service_name=$1
    local service_dir=$2
    local output_file="${service_name}-source.txt"
    
    echo "Extracting ${service_name}..."
    
    # In Service-Verzeichnis wechseln
    cd "$service_dir"
    
    # Output-File erstellen
    echo "# HIS ${service_name} - Complete Source Code Structure" > "$output_file"
    echo "Generated: $(date)" >> "$output_file"
    echo "Project: Hospital Information System (HIS) - ${service_name}" >> "$output_file"
    echo "=========================================================" >> "$output_file"
    echo "" >> "$output_file"
    
    # Verzeichnisstruktur anzeigen (ohne Backups)
    echo "## Directory Structure" >> "$output_file"
    echo "\`\`\`" >> "$output_file"
    find . -type f \( -name "*.java" -o -name "*.yml" -o -name "*.yaml" -o -name "*.properties" -o -name "*.xml" -o -name "*.sql" -o -name "Dockerfile" -o -name "*.md" -o -name "*.js" -o -name "*.jsx" -o -name "*.ts" -o -name "*.tsx" -o -name "*.css" -o -name "*.scss" -o -name "*.json" -o -name "*.html" \) | grep -v target/ | grep -v .git/ | grep -v node_modules/ | grep -v build/ | grep -v dist/ | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | sort >> "$output_file"
    echo "\`\`\`" >> "$output_file"
    echo "" >> "$output_file"
    
    # Tree-Struktur
    echo "## Tree Structure" >> "$output_file"
    echo "\`\`\`" >> "$output_file"
    if command -v tree >/dev/null 2>&1; then
        tree -I 'target|.git|*.class|*.jar|node_modules|build|dist|backup*|*.bak|*.backup|*~' >> "$output_file"
    else
        echo "tree command not available - using find alternative:" >> "$output_file"
        find . -type d | grep -v target/ | grep -v .git/ | grep -v node_modules/ | grep -v build/ | grep -v dist/ | grep -v backup | sort | sed 's/[^/]*\//|  /g; s/|  \([^|]\)/+--\1/' >> "$output_file"
    fi
    echo "\`\`\`" >> "$output_file"
    echo "" >> "$output_file"
    
    # Source Code Files
    echo "## Source Code Files" >> "$output_file"
    echo "" >> "$output_file"
    
    # Java Files
    find . -name "*.java" | grep -v target/ | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | sort | while read file; do
        echo "### File: $file" >> "$output_file"
        echo "\`\`\`java" >> "$output_file"
        cat "$file" >> "$output_file"
        echo "" >> "$output_file"
        echo "\`\`\`" >> "$output_file"
        echo "" >> "$output_file"
    done
    
    # JavaScript/TypeScript Files
    find . \( -name "*.js" -o -name "*.jsx" -o -name "*.ts" -o -name "*.tsx" \) | grep -v target/ | grep -v node_modules/ | grep -v build/ | grep -v dist/ | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | sort | while read file; do
        # Dateiendung f√ºr Syntax-Highlighting ermitteln
        ext=$(echo "$file" | sed 's/.*\.//')
        case $ext in
            js|jsx) syntax="javascript" ;;
            ts|tsx) syntax="typescript" ;;
            *) syntax="javascript" ;;
        esac
        
        echo "### File: $file" >> "$output_file"
        echo "\`\`\`$syntax" >> "$output_file"
        cat "$file" >> "$output_file"
        echo "" >> "$output_file"
        echo "\`\`\`" >> "$output_file"
        echo "" >> "$output_file"
    done
    
    # CSS/SCSS Files
    find . \( -name "*.css" -o -name "*.scss" \) | grep -v target/ | grep -v node_modules/ | grep -v build/ | grep -v dist/ | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | sort | while read file; do
        echo "### File: $file" >> "$output_file"
        echo "\`\`\`css" >> "$output_file"
        cat "$file" >> "$output_file"
        echo "" >> "$output_file"
        echo "\`\`\`" >> "$output_file"
        echo "" >> "$output_file"
    done
    
    # HTML Files
    find . -name "*.html" | grep -v target/ | grep -v node_modules/ | grep -v build/ | grep -v dist/ | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | sort | while read file; do
        echo "### File: $file" >> "$output_file"
        echo "\`\`\`html" >> "$output_file"
        cat "$file" >> "$output_file"
        echo "" >> "$output_file"
        echo "\`\`\`" >> "$output_file"
        echo "" >> "$output_file"
    done
    
    # JSON Files (package.json, etc.)
    find . -name "*.json" | grep -v target/ | grep -v node_modules/ | grep -v build/ | grep -v dist/ | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | sort | while read file; do
        echo "### File: $file" >> "$output_file"
        echo "\`\`\`json" >> "$output_file"
        cat "$file" >> "$output_file"
        echo "" >> "$output_file"
        echo "\`\`\`" >> "$output_file"
        echo "" >> "$output_file"
    done
    
    # Configuration Files
    for ext in yml yaml properties; do
        find . -name "*.$ext" | grep -v target/ | grep -v node_modules/ | grep -v build/ | grep -v dist/ | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | sort | while read file; do
            echo "### File: $file" >> "$output_file"
            echo "\`\`\`$ext" >> "$output_file"
            cat "$file" >> "$output_file"
            echo "" >> "$output_file"
            echo "\`\`\`" >> "$output_file"
            echo "" >> "$output_file"
        done
    done
    
    # XML Files
    find . -name "*.xml" | grep -v target/ | grep -v node_modules/ | grep -v build/ | grep -v dist/ | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | sort | while read file; do
        echo "### File: $file" >> "$output_file"
        echo "\`\`\`xml" >> "$output_file"
        cat "$file" >> "$output_file"
        echo "" >> "$output_file"
        echo "\`\`\`" >> "$output_file"
        echo "" >> "$output_file"
    done
    
    # SQL Files
    find . -name "*.sql" | grep -v target/ | grep -v node_modules/ | grep -v build/ | grep -v dist/ | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | sort | while read file; do
        echo "### File: $file" >> "$output_file"
        echo "\`\`\`sql" >> "$output_file"
        cat "$file" >> "$output_file"
        echo "" >> "$output_file"
        echo "\`\`\`" >> "$output_file"
        echo "" >> "$output_file"
    done
    
    # Dockerfile
    if [ -f "Dockerfile" ] && ! echo "Dockerfile" | grep -q -E "(backup|\.bak|\.backup|~$)"; then
        echo "### File: ./Dockerfile" >> "$output_file"
        echo "\`\`\`dockerfile" >> "$output_file"
        cat Dockerfile >> "$output_file"
        echo "" >> "$output_file"
        echo "\`\`\`" >> "$output_file"
        echo "" >> "$output_file"
    fi
    
    # Markdown Files
    find . -name "*.md" | grep -v target/ | grep -v node_modules/ | grep -v build/ | grep -v dist/ | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | sort | while read file; do
        echo "### File: $file" >> "$output_file"
        echo "\`\`\`markdown" >> "$output_file"
        cat "$file" >> "$output_file"
        echo "" >> "$output_file"
        echo "\`\`\`" >> "$output_file"
        echo "" >> "$output_file"
    done
    
    # File in Sources Verzeichnis kopieren
    cp "$output_file" "../Sources/"
    
    # Zur√ºck zum Root-Verzeichnis
    cd ..
    
    echo "${service_name} extraction completed: Sources/${output_file}"
}

# Root Directory Files extrahieren
extract_root_files() {
    echo "Extracting Root Directory files..."
    
    local output_file="his-project-root-source.txt"
    
    # Output-File erstellen
    echo "# HIS Project Root - Configuration and Infrastructure Files" > "$output_file"
    echo "Generated: $(date)" >> "$output_file"
    echo "Project: Hospital Information System (HIS) - Root Directory" >> "$output_file"
    echo "=========================================================" >> "$output_file"
    echo "" >> "$output_file"
    
    # Root Directory Structure
    echo "## Root Directory Structure" >> "$output_file"
    echo "\`\`\`" >> "$output_file"
    find . -maxdepth 2 -type f \( -name "*.yml" -o -name "*.yaml" -o -name "*.md" -o -name "*.txt" -o -name "*.json" -o -name "*.xml" -o -name "*.properties" -o -name "Dockerfile" -o -name "*.sh" \) | grep -v backup | grep -v "\.bak" | grep -v "\.backup" | grep -v "~$" | grep -v "/target/" | grep -v "/node_modules/" | grep -v "/build/" | grep -v "/dist/" | grep -v "Sources/" | sort >> "$output_file"
    echo "\`\`\`" >> "$output_file"
    echo "" >> "$output_file"
    
    # Services Overview
    echo "## Available Services" >> "$output_file"
    echo "\`\`\`" >> "$output_file"
    ls -la | grep "^d" | grep -E "(his-|init-)" >> "$output_file"
    echo "\`\`\`" >> "$output_file"
    echo "" >> "$output_file"
    
    # Root Configuration Files
    echo "## Root Configuration Files" >> "$output_file"
    echo "" >> "$output_file"
    
    # Docker Compose Files
    for file in docker-compose*.yml docker-compose*.yaml; do
        if [ -f "$file" ] && ! echo "$file" | grep -q -E "(backup|\.bak|\.backup|~$)"; then
            echo "### File: ./$file" >> "$output_file"
            echo "\`\`\`yaml" >> "$output_file"
            cat "$file" >> "$output_file"
            echo "" >> "$output_file"
            echo "\`\`\`" >> "$output_file"
            echo "" >> "$output_file"
        fi
    done
    
    # README Files
    for file in README*.md readme*.md; do
        if [ -f "$file" ] && ! echo "$file" | grep -q -E "(backup|\.bak|\.backup|~$)"; then
            echo "### File: ./$file" >> "$output_file"
            echo "\`\`\`markdown" >> "$output_file"
            cat "$file" >> "$output_file"
            echo "" >> "$output_file"
            echo "\`\`\`" >> "$output_file"
            echo "" >> "$output_file"
        fi
    done
    
    # Other Configuration Files
    for file in *.json *.xml *.properties *.txt; do
        if [ -f "$file" ] && ! echo "$file" | grep -q -E "(backup|\.bak|\.backup|~$)" && ! echo "$file" | grep -q "source\.txt$"; then
            echo "### File: ./$file" >> "$output_file"
            echo "\`\`\`" >> "$output_file"
            cat "$file" >> "$output_file"
            echo "" >> "$output_file"
            echo "\`\`\`" >> "$output_file"
            echo "" >> "$output_file"
        fi
    done
    
    # Shell Scripts
    for file in *.sh; do
        if [ -f "$file" ] && ! echo "$file" | grep -q -E "(backup|\.bak|\.backup|~$)"; then
            echo "### File: ./$file" >> "$output_file"
            echo "\`\`\`bash" >> "$output_file"
            cat "$file" >> "$output_file"
            echo "" >> "$output_file"
            echo "\`\`\`" >> "$output_file"
            echo "" >> "$output_file"
        fi
    done
    
    # File in Sources Verzeichnis kopieren
    cp "$output_file" "Sources/"
    
    echo "Root directory extraction completed: Sources/$output_file"
}

# Hauptausf√ºhrung
echo "Starting HIS Project Source Code Extraction..."
echo "=============================================="

# Root Files extrahieren
extract_root_files

# Init Scripts als separater Service extrahieren
if [ -d "init-scripts" ]; then
    extract_service "Init Scripts" "init-scripts"
else
    echo "Warning: init-scripts directory not found"
fi

# Backend Services extrahieren
if [ -d "his-encounter-service" ]; then
    extract_service "Encounter Service" "his-encounter-service"
else
    echo "Warning: his-encounter-service directory not found"
fi

if [ -d "his-patient-service" ]; then
    extract_service "Patient Service" "his-patient-service"
else
    echo "Warning: his-patient-service directory not found"
fi

if [ -d "his-api-gateway" ]; then
    extract_service "API Gateway" "his-api-gateway"
else
    echo "Warning: his-api-gateway directory not found"
fi

# React Frontend extrahieren
if [ -d "his-frontend" ]; then
    extract_service "React Frontend" "his-frontend"
else
    echo "Warning: his-frontend directory not found"
fi

# Zusammenfassung erstellen
echo ""
echo "Creating extraction summary..."
summary_file="Sources/00-extraction-summary.txt"
echo "HIS Project Source Code Extraction Summary" > "$summary_file"
echo "Generated: $(date)" >> "$summary_file"
echo "==========================================" >> "$summary_file"
echo "" >> "$summary_file"
echo "Extracted Files:" >> "$summary_file"
ls -la Sources/ >> "$summary_file"
echo "" >> "$summary_file"
echo "File Sizes:" >> "$summary_file"
du -h Sources/* >> "$summary_file"

echo ""
echo "=============================================="
echo "Extraction Summary:"
echo "- All files are now available in: ./Sources/"
echo "- Root Directory: Sources/his-project-root-source.txt"
if [ -d "init-scripts" ]; then
    echo "- Init Scripts: Sources/Init Scripts-source.txt"
fi
if [ -d "his-encounter-service" ]; then
    echo "- Encounter Service: Sources/Encounter Service-source.txt"
fi
if [ -d "his-patient-service" ]; then
    echo "- Patient Service: Sources/Patient Service-source.txt"
fi
if [ -d "his-api-gateway" ]; then
    echo "- API Gateway: Sources/API Gateway-source.txt"
fi
if [ -d "his-frontend" ]; then
    echo "- React Frontend: Sources/React Frontend-source.txt"
fi
echo "- Summary: Sources/00-extraction-summary.txt"
echo ""
echo "All source code extractions completed and copied to Sources directory!"
```

### File: ./frontend_working_solution.sh
```bash
#!/bin/bash

# Frontend Working Solution - Sofort einsetzbar
# Alle funktionierenden APIs + Workarounds f√ºr nicht funktionierende

AUTH_HEADER="Authorization: Basic $(echo -n 'admin:dev-password' | base64)"

echo "üöÄ Frontend Working Solution - Sofort einsetzbar"
echo "================================================"

# =================================================================
# 1. WORKING PATIENT CREATION (f√ºr Frontend Forms)
# =================================================================

echo ""
echo "1Ô∏è‚É£ Working Patient Creation APIs"
echo "--------------------------------"

# Generiere g√ºltige KVNR (1 Buchstabe + 9 Ziffern)
generate_valid_kvnr() {
    local prefix=$1
    printf "${prefix}%09d" $(($(date +%s) % 1000000000))
}

echo "Erstelle realistische Testpatienten f√ºr Frontend-Entwicklung:"

# Frontend Test Patient 1 (Male, GKV)
MALE_KVNR=$(generate_valid_kvnr "M")
echo ""
echo "Creating Male Patient (f√ºr Frontend PatientForm):"
MALE_PATIENT=$(curl -s -X POST http://localhost:8080/api/v1/patients \
  -H "Content-Type: application/json" \
  -H "$AUTH_HEADER" \
  -d "{
    \"firstName\": \"Max\",
    \"lastName\": \"Frontend\",
    \"title\": \"Herr\",
    \"birthDate\": \"1985-07-15\",
    \"gender\": \"MALE\",
    \"kvnr\": \"$MALE_KVNR\",
    \"insuranceType\": \"STATUTORY\",
    \"insuranceCompanyName\": \"AOK Bayern\",
    \"phone\": \"+49 89 12345678\",
    \"email\": \"max.frontend@test.com\",
    \"consentCommunication\": true,
    \"consentDataProcessing\": true
  }")

MALE_ID=$(echo "$MALE_PATIENT" | jq -r '.id')
echo "‚úÖ Male Patient ID: $MALE_ID"
echo "   Name: $(echo "$MALE_PATIENT" | jq -r '.firstName + " " + .lastName')"
echo "   KVNR: $(echo "$MALE_PATIENT" | jq -r '.kvnr')"

# Frontend Test Patient 2 (Female, PKV)
FEMALE_KVNR=$(generate_valid_kvnr "A")
echo ""
echo "Creating Female Patient (f√ºr Frontend PatientForm):"
FEMALE_PATIENT=$(curl -s -X POST http://localhost:8080/api/v1/patients \
  -H "Content-Type: application/json" \
  -H "$AUTH_HEADER" \
  -d "{
    \"firstName\": \"Anna\",
    \"lastName\": \"Frontend\",
    \"title\": \"Dr.\",
    \"birthDate\": \"1992-03-22\",
    \"gender\": \"FEMALE\",
    \"kvnr\": \"$FEMALE_KVNR\",
    \"insuranceType\": \"PRIVATE\",
    \"insuranceCompanyName\": \"Debeka\",
    \"phone\": \"+49 30 98765432\",
    \"email\": \"dr.anna.frontend@test.com\",
    \"consentCommunication\": true,
    \"consentDataProcessing\": false
  }")

FEMALE_ID=$(echo "$FEMALE_PATIENT" | jq -r '.id')
echo "‚úÖ Female Patient ID: $FEMALE_ID"
echo "   Name: $(echo "$FEMALE_PATIENT" | jq -r '.firstName + " " + .lastName')"
echo "   KVNR: $(echo "$FEMALE_PATIENT" | jq -r '.kvnr')"

# =================================================================
# 2. WORKING ENCOUNTER CREATION (f√ºr Frontend Forms)
# =================================================================

echo ""
echo "2Ô∏è‚É£ Working Encounter Creation APIs"
echo "----------------------------------"

if [ "$MALE_ID" != "null" ]; then
    echo "Creating Encounters f√ºr Frontend EncounterForm:"
    
    # Encounter 1: INITIAL
    PRACTITIONER_1=$(uuidgen | tr '[:upper:]' '[:lower:]')
    ENCOUNTER_1=$(curl -s -X POST http://localhost:8080/api/v1/encounters \
      -H "Content-Type: application/json" \
      -H "$AUTH_HEADER" \
      -d "{
        \"patientId\": \"$MALE_ID\",
        \"practitionerId\": \"$PRACTITIONER_1\",
        \"type\": \"INITIAL\",
        \"encounterDate\": \"$(date -u +%Y-%m-%dT%H:%M:%S)\",
        \"billingContext\": \"GKV\"
      }")
    
    ENCOUNTER_1_ID=$(echo "$ENCOUNTER_1" | jq -r '.id')
    echo "‚úÖ Encounter 1 (INITIAL): $ENCOUNTER_1_ID"
    
    # Encounter 2: CONSULTATION  
    PRACTITIONER_2=$(uuidgen | tr '[:upper:]' '[:lower:]')
    ENCOUNTER_2=$(curl -s -X POST http://localhost:8080/api/v1/encounters \
      -H "Content-Type: application/json" \
      -H "$AUTH_HEADER" \
      -d "{
        \"patientId\": \"$FEMALE_ID\",
        \"practitionerId\": \"$PRACTITIONER_2\",
        \"type\": \"CONSULTATION\",
        \"encounterDate\": \"$(date -u +%Y-%m-%dT%H:%M:%S)\",
        \"billingContext\": \"PKV\"
      }")
    
    ENCOUNTER_2_ID=$(echo "$ENCOUNTER_2" | jq -r '.id')
    echo "‚úÖ Encounter 2 (CONSULTATION): $ENCOUNTER_2_ID"
fi

# =================================================================
# 3. WORKING ENCOUNTER STATUS UPDATES (f√ºr Frontend Actions)
# =================================================================

echo ""
echo "3Ô∏è‚É£ Working Encounter Status Updates"
echo "-----------------------------------"

if [ "$ENCOUNTER_1_ID" != "null" ]; then
    echo "Testing Encounter Status Updates (React Action Buttons):"
    
    # Start Encounter
    echo "  Starting Encounter: PLANNED ‚Üí IN_PROGRESS"
    START_RESULT=$(curl -s -X PUT http://localhost:8080/api/v1/encounters/$ENCOUNTER_1_ID/start \
      -H "$AUTH_HEADER")
    echo "  ‚úÖ Status: $(echo "$START_RESULT" | jq -r '.status')"
    
    sleep 1
    
    # Complete Encounter
    echo "  Completing Encounter: IN_PROGRESS ‚Üí COMPLETED"
    COMPLETE_RESULT=$(curl -s -X PUT http://localhost:8080/api/v1/encounters/$ENCOUNTER_1_ID/complete \
      -H "$AUTH_HEADER")
    echo "  ‚úÖ Status: $(echo "$COMPLETE_RESULT" | jq -r '.status')"
fi

# =================================================================
# 4. WORKING SINGLE ENCOUNTER GET (f√ºr Frontend Detail Views)
# =================================================================

echo ""
echo "4Ô∏è‚É£ Working Single Encounter GET"
echo "-------------------------------"

if [ "$ENCOUNTER_1_ID" != "null" ]; then
    echo "Testing Single Encounter GET (React EncounterDetail Component):"
    SINGLE_ENCOUNTER=$(curl -s -H "$AUTH_HEADER" \
      http://localhost:8080/api/v1/encounters/$ENCOUNTER_1_ID)
    
    echo "‚úÖ Single Encounter Response:"
    echo "$SINGLE_ENCOUNTER" | jq '{
      id,
      patientId,
      type,
      status,
      encounterDate,
      billingContext
    }'
fi

# =================================================================
# 5. WORKING PATIENT ENCOUNTERS (f√ºr Frontend Patient Detail)
# =================================================================

echo ""
echo "5Ô∏è‚É£ Working Patient Encounters GET"
echo "---------------------------------"

if [ "$MALE_ID" != "null" ]; then
    echo "Testing Patient Encounters (React PatientDetail Component):"
    PATIENT_ENCOUNTERS=$(curl -s -H "$AUTH_HEADER" \
      http://localhost:8080/api/v1/encounters/patient/$MALE_ID)
    
    echo "‚úÖ Patient Encounters Response:"
    echo "$PATIENT_ENCOUNTERS" | jq '{
      totalElements,
      totalPages,
      size,
      content: .content | map({
        id,
        type,
        status,
        encounterDate,
        documentationCount
      })
    }'
fi

# =================================================================
# 6. FRONTEND DASHBOARD WORKAROUND (Client-side Aggregation)
# =================================================================

echo ""
echo "6Ô∏è‚É£ Frontend Dashboard Workaround"
echo "--------------------------------"

echo "Da Patient List API nicht funktioniert, erstellen wir eine Alternative:"

# Sammle alle erstellten Patienten-IDs
KNOWN_PATIENT_IDS=("$MALE_ID" "$FEMALE_ID")

echo "Frontend Dashboard Daten (aus bekannten Patienten):"

DASHBOARD_DATA="{"
TOTAL_PATIENTS=0
TOTAL_ENCOUNTERS=0
ALL_ENCOUNTERS="[]"

for patient_id in "${KNOWN_PATIENT_IDS[@]}"; do
    if [ "$patient_id" != "null" ] && [ -n "$patient_id" ]; then
        TOTAL_PATIENTS=$((TOTAL_PATIENTS + 1))
        
        # Lade Encounters f√ºr diesen Patient
        PATIENT_ENC=$(curl -s -H "$AUTH_HEADER" \
          http://localhost:8080/api/v1/encounters/patient/$patient_id)
        
        PATIENT_ENC_COUNT=$(echo "$PATIENT_ENC" | jq '.totalElements // 0')
        TOTAL_ENCOUNTERS=$((TOTAL_ENCOUNTERS + PATIENT_ENC_COUNT))
        
        # F√ºge Encounters zur Gesamtliste hinzu
        ALL_ENCOUNTERS=$(echo "$ALL_ENCOUNTERS" "$PATIENT_ENC" | jq -s '.[0] + (.[1].content // [])')
    fi
done

echo "‚úÖ Dashboard Statistiken (Client-side aggregiert):"
echo "   Total Patients: $TOTAL_PATIENTS"
echo "   Total Encounters: $TOTAL_ENCOUNTERS"

echo ""
echo "‚úÖ Encounter Status Distribution:"
echo "$ALL_ENCOUNTERS" | jq 'group_by(.status) | map({status: .[0].status, count: length})'

echo ""
echo "‚úÖ Encounter Type Distribution:"
echo "$ALL_ENCOUNTERS" | jq 'group_by(.type) | map({type: .[0].type, count: length})'

# =================================================================
# 7. REACT FRONTEND INTEGRATION CODE
# =================================================================

echo ""
echo "7Ô∏è‚É£ React Frontend Integration Code"
echo "----------------------------------"

cat << 'EOF'
// React Frontend API Integration (funktioniert sofort)

const API_BASE = 'http://localhost:8080/api/v1';
const AUTH_HEADER = 'Basic ' + btoa('admin:dev-password');

// ‚úÖ WORKING: Patient Creation (PatientForm)
const createPatient = async (patientData) => {
  const response = await fetch(`${API_BASE}/patients`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': AUTH_HEADER
    },
    body: JSON.stringify(patientData)
  });
  return response.json();
};

// ‚úÖ WORKING: Encounter Creation (EncounterForm)
const createEncounter = async (encounterData) => {
  const response = await fetch(`${API_BASE}/encounters`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': AUTH_HEADER
    },
    body: JSON.stringify(encounterData)
  });
  return response.json();
};

// ‚úÖ WORKING: Single Encounter (EncounterDetail)
const getEncounter = async (encounterId) => {
  const response = await fetch(`${API_BASE}/encounters/${encounterId}`, {
    headers: { 'Authorization': AUTH_HEADER }
  });
  return response.json();
};

// ‚úÖ WORKING: Patient Encounters (PatientDetail)
const getPatientEncounters = async (patientId) => {
  const response = await fetch(`${API_BASE}/encounters/patient/${patientId}`, {
    headers: { 'Authorization': AUTH_HEADER }
  });
  return response.json();
};

// ‚úÖ WORKING: Encounter Status Updates (Action Buttons)
const startEncounter = async (encounterId) => {
  const response = await fetch(`${API_BASE}/encounters/${encounterId}/start`, {
    method: 'PUT',
    headers: { 'Authorization': AUTH_HEADER }
  });
  return response.json();
};

const completeEncounter = async (encounterId) => {
  const response = await fetch(`${API_BASE}/encounters/${encounterId}/complete`, {
    method: 'PUT',
    headers: { 'Authorization': AUTH_HEADER }
  });
  return response.json();
};

// üîß WORKAROUND: Dashboard Statistics (Client-side)
const getDashboardStats = async () => {
  // Da Patient List nicht funktioniert, verwenden Sie bekannte Patient-IDs
  const knownPatientIds = ['patient-id-1', 'patient-id-2']; // Aus localStorage oder State
  
  let totalEncounters = 0;
  const allEncounters = [];
  
  for (const patientId of knownPatientIds) {
    const patientEncounters = await getPatientEncounters(patientId);
    totalEncounters += patientEncounters.totalElements;
    allEncounters.push(...patientEncounters.content);
  }
  
  return {
    totalPatients: knownPatientIds.length,
    totalEncounters,
    encountersByStatus: allEncounters.reduce((acc, enc) => {
      acc[enc.status] = (acc[enc.status] || 0) + 1;
      return acc;
    }, {}),
    encountersByType: allEncounters.reduce((acc, enc) => {
      acc[enc.type] = (acc[enc.type] || 0) + 1;
      return acc;
    }, {})
  };
};

EOF

# =================================================================
# FRONTEND READY SUMMARY
# =================================================================

echo ""
echo "=================================================="
echo "üéâ FRONTEND READY - SOFORT EINSETZBAR!"
echo "=================================================="
echo ""
echo "‚úÖ FUNKTIONIERT SOFORT:"
echo "  ‚Ä¢ Patient Creation Forms ‚úì"
echo "  ‚Ä¢ Encounter Creation Forms ‚úì"
echo "  ‚Ä¢ Encounter Detail Views ‚úì"
echo "  ‚Ä¢ Patient Detail Views (mit Encounters) ‚úì"
echo "  ‚Ä¢ Encounter Status Updates (Start/Complete) ‚úì"
echo "  ‚Ä¢ Dashboard (mit Client-side Aggregation) ‚úì"
echo ""
echo "‚ùå EINZIGES PROBLEM:"
echo "  ‚Ä¢ Patient List/Search API (HTTP 500)"
echo "  ‚Ä¢ Workaround: Verwenden Sie bekannte Patient-IDs"
echo ""
echo "üöÄ FRONTEND KANN SOFORT ENTWICKELT WERDEN:"
echo "  ‚Ä¢ Alle CRUD-Operationen funktionieren"
echo "  ‚Ä¢ Alle Status-Updates funktionieren"
echo "  ‚Ä¢ Dashboard-Daten k√∂nnen aggregiert werden"
echo ""
echo "üìã PATIENT-IDs F√úR TESTS:"
echo "  ‚Ä¢ Male Patient: $MALE_ID"
echo "  ‚Ä¢ Female Patient: $FEMALE_ID"
echo ""
echo "üîß NEXT STEPS:"
echo "  1. Frontend mit funktionierenden APIs entwickeln"
echo "  2. Patient List Problem separat l√∂sen"
echo "  3. Dann Patient List in Frontend integrieren"
```

### File: ./his_curl_testdata.sh
```bash
# HIS Testdaten - Projektkonform
# Basierend auf der tats√§chlichen API-Struktur aus dem Projektwissen

# ===== PATIENT TESTDATEN =====

# 1. Standardpatient (GKV) - Max Mustermann
echo "üè• Erstelle Patient: Max Mustermann"
curl -s -X POST http://localhost:8080/api/v1/patients \
  -H "Content-Type: application/json" \
  -H "Authorization: Basic $(echo -n 'admin:dev-password' | base64)" \
  -d '{
    "firstName": "Max",
    "lastName": "Mustermann", 
    "birthDate": "1990-07-15",
    "gender": "MALE",
    "kvnr": "M123456780",
    "insuranceNumber": "A123456780",
    "insuranceType": "STATUTORY",
    "insuranceCompanyId": "104212059",
    "insuranceCompanyName": "AOK Bayern",
    "phone": "+49 89 12345678",
    "email": "max.mustermann@example.com",
    "consentCommunication": true,
    "consentDataProcessing": true
  }' | jq '{id, firstName, lastName, birthDate, gender, kvnr, insuranceType}'

# 2. Weibliche Patientin (PKV) - Dr. Anna Schmidt  
echo "üè• Erstelle Patientin: Dr. Anna Schmidt"
curl -s -X POST http://localhost:8080/api/v1/patients \
  -H "Content-Type: application/json" \
  -H "Authorization: Basic $(echo -n 'admin:dev-password' | base64)" \
  -d '{
    "firstName": "Anna",
    "lastName": "Schmidt",
    "title": "Dr.",
    "birthDate": "1985-03-22",
    "gender": "FEMALE", 
    "kvnr": "A198503221",
    "insuranceNumber": "PKV-198503221",
    "insuranceType": "PRIVATE",
    "insuranceCompanyName": "Debeka Krankenversicherung",
    "phone": "+49 30 98765432",
    "email": "dr.anna.schmidt@example.com",
    "consentCommunication": true,
    "consentDataProcessing": false
  }' | jq '{id, firstName, lastName, title, birthDate, gender, kvnr, insuranceType}'

# 3. P√§diatrischer Patient - Tim Weber (minderj√§hrig)
echo "üè• Erstelle Patient: Tim Weber (minderj√§hrig)"
curl -s -X POST http://localhost:8080/api/v1/patients \
  -H "Content-Type: application/json" \
  -H "Authorization: Basic $(echo -n 'admin:dev-password' | base64)" \
  -d '{
    "firstName": "Tim",
    "lastName": "Weber",
    "birthDate": "2015-11-08", 
    "gender": "MALE",
    "kvnr": "T201511083",
    "insuranceNumber": "T201511083",
    "insuranceType": "STATUTORY",
    "insuranceCompanyName": "Techniker Krankenkasse",
    "phone": "+49 40 11223344",
    "email": "familie.weber@example.com",
    "consentCommunication": true,
    "consentDataProcessing": true
  }' | jq '{id, firstName, lastName, birthDate, gender, kvnr, age: ((now | strftime("%Y") | tonumber) - (.birthDate | split("-")[0] | tonumber))}'

# 4. Senior Patient - Gertrud M√ºller (65+)
echo "üè• Erstelle Patientin: Gertrud M√ºller (65+)"
curl -s -X POST http://localhost:8080/api/v1/patients \
  -H "Content-Type: application/json" \
  -H "Authorization: Basic $(echo -n 'admin:dev-password' | base64)" \
  -d '{
    "firstName": "Gertrud",
    "lastName": "M√ºller",
    "birthDate": "1950-12-03",
    "gender": "FEMALE",
    "kvnr": "G195012034", 
    "insuranceNumber": "G195012034",
    "insuranceType": "STATUTORY",
    "insuranceCompanyName": "Barmer",
    "phone": "+49 221 55443322",
    "email": "gertrud.mueller@example.com",
    "consentCommunication": false,
    "consentDataProcessing": true
  }' | jq '{id, firstName, lastName, birthDate, gender, kvnr, insuranceType}'

# 5. Patient mit komplexeren Daten - Prof. Dr. Hans Zimmerman
echo "üè• Erstelle Patient: Prof. Dr. Hans Zimmerman"
curl -s -X POST http://localhost:8080/api/v1/patients \
  -H "Content-Type: application/json" \
  -H "Authorization: Basic $(echo -n 'admin:dev-password' | base64)" \
  -d '{
    "firstName": "Hans",
    "lastName": "Zimmerman", 
    "title": "Prof. Dr.",
    "birthDate": "1975-09-12",
    "gender": "MALE",
    "kvnr": "H197509125",
    "insuranceNumber": "PKV-H197509125",
    "insuranceType": "PRIVATE",
    "insuranceCompanyId": "168141347",
    "insuranceCompanyName": "DKV Deutsche Krankenversicherung",
    "phone": "+49 69 87654321",
    "email": "prof.zimmerman@uni-frankfurt.de",
    "consentCommunication": true,
    "consentDataProcessing": true
  }' | jq '{id, firstName, lastName, title, birthDate, gender, kvnr, insuranceType}'

# ===== SYSTEM VALIDIERUNG =====

echo ""
echo "üîç System-Validierung:"

# Alle Patienten abrufen
echo "üìã Alle erstellten Patienten:"
curl -s http://localhost:8080/api/v1/patients | jq '.[] | {id, firstName, lastName, kvnr, insuranceType}'

# Health Check
echo ""
echo "üè• System Health:"
curl -s http://localhost:8080/actuator/health | jq

echo ""
echo "‚úÖ Testdaten erfolgreich erstellt!"
echo "üåê Frontend testen: http://localhost:3000"
echo "üìä API Docs: http://localhost:8080/swagger-ui.html"

# ===== KVNR VALIDIERUNG TESTS =====

echo ""
echo "üß™ KVNR-Validierung Tests:"

# Test: Ung√ºltige KVNR (zu kurz)
echo "‚ùå Test: Ung√ºltige KVNR (zu kurz)"
curl -s -X POST http://localhost:8080/api/v1/patients \
  -H "Content-Type: application/json" \
  -H "Authorization: Basic $(echo -n 'admin:dev-password' | base64)" \
  -d '{
    "firstName": "Test",
    "lastName": "Invalid",
    "birthDate": "1990-01-01", 
    "gender": "MALE",
    "kvnr": "ABC123"
  }' | jq '.message // .error // "Validation failed as expected"'

# Test: KVNR mit verbotenem Buchstaben 'O'
echo "‚ùå Test: KVNR mit verbotenem Buchstaben O"
curl -s -X POST http://localhost:8080/api/v1/patients \
  -H "Content-Type: application/json" \
  -H "Authorization: Basic $(echo -n 'admin:dev-password' | base64)" \
  -d '{
    "firstName": "Test",
    "lastName": "InvalidO",
    "birthDate": "1990-01-01",
    "gender": "MALE", 
    "kvnr": "O123456789"
  }' | jq '.message // .error // "Validation failed as expected"'

# Test: Fehlende Pflichtfelder
echo "‚ùå Test: Fehlende Pflichtfelder"
curl -s -X POST http://localhost:8080/api/v1/patients \
  -H "Content-Type: application/json" \
  -H "Authorization: Basic $(echo -n 'admin:dev-password' | base64)" \
  -d '{
    "firstName": "Test"
  }' | jq '.message // .error // "Validation failed as expected"'

# ===== ENCOUNTER TESTDATEN (wenn Patient IDs vorhanden) =====

echo ""
echo "üìã Encounter-Testdaten erstellen..."

# Erste Patient-ID f√ºr Encounter-Tests abrufen
PATIENT_ID=$(curl -s http://localhost:8080/api/v1/patients | jq -r '.[0].id // empty')

if [ ! -z "$PATIENT_ID" ]; then
    echo "üè• Erstelle Encounter f√ºr Patient: $PATIENT_ID"
    curl -s -X POST http://localhost:8080/api/v1/encounters \
      -H "Content-Type: application/json" \
      -H "Authorization: Basic $(echo -n 'admin:dev-password' | base64)" \
      -d "{
        \"patientId\": \"$PATIENT_ID\",
        \"practitionerId\": \"$(uuidgen)\",
        \"type\": \"INITIAL\",
        \"encounterDate\": \"$(date -u +%Y-%m-%dT%H:%M:%S)\",
        \"billingContext\": \"GKV\",
        \"notes\": \"Erstuntersuchung - Testdaten\"
      }" | jq '{id, patientId, type, encounterDate, status}'
else
    echo "‚ö†Ô∏è Keine Patienten gefunden - Encounter nicht erstellt"
fi

echo ""
echo "üéØ Testdaten-Setup abgeschlossen!"
echo "üöÄ Frontend starten: npm start (in his-frontend/)"
echo "üìä Backend l√§uft auf: http://localhost:8080"
```

### File: ./setup-elk.sh
```bash
#!/bin/bash
# setup-elk.sh - ELK Stack Konfiguration erstellen

set -e

echo "üîç Setting up ELK Stack Configuration..."

# Farben f√ºr Output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m'

print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# 1. Verzeichnisse erstellen
print_status "Creating ELK configuration directories..."
mkdir -p elk-config/logstash/config
mkdir -p elk-config/logstash/pipeline
mkdir -p elk-config/kibana
mkdir -p elk-config/filebeat
mkdir -p logs/elk

print_success "Directories created"

# 2. Logstash Konfiguration
print_status "Creating Logstash configuration..."
cat > elk-config/logstash/config/logstash.yml << 'EOF'
http.host: "0.0.0.0"
xpack.monitoring.elasticsearch.hosts: [ "http://elasticsearch:9200" ]
path.config: /usr/share/logstash/pipeline
EOF

# 3. Logstash Pipeline f√ºr HIS Services
print_status "Creating Logstash pipeline..."
cat > elk-config/logstash/pipeline/logstash.conf << 'EOF'
input {
  # Filebeat input
  beats {
    port => 5044
  }
  
  # TCP input f√ºr direkte Service-Logs
  tcp {
    port => 5001
    codec => json_lines
  }
  
  # UDP input (optional)
  udp {
    port => 5001
    codec => json_lines
  }
}

filter {
  # Service-spezifische Filter
  if [fields][service] {
    mutate {
      add_field => { "service_name" => "%{[fields][service]}" }
    }
  }
  
  # Docker Labels verarbeiten
  if [container][labels][service] {
    mutate {
      add_field => { "service_name" => "%{[container][labels][service]}" }
    }
  }
  
  # Log Level extrahieren
  grok {
    match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{DATA:thread}\] %{LOGLEVEL:level} %{DATA:logger} - %{GREEDYDATA:log_message}" }
    tag_on_failure => ["_grokparsefailure"]
  }
  
  # Timestamp parsen
  date {
    match => [ "timestamp", "yyyy-MM-dd HH:mm:ss.SSS" ]
  }
  
  # Service-spezifische Enrichments
  if [service_name] == "api-gateway" {
    mutate {
      add_field => { "component" => "gateway" }
      add_field => { "system" => "his" }
    }
  }
  
  if [service_name] == "patient-service" {
    mutate {
      add_field => { "component" => "patient" }
      add_field => { "system" => "his" }
    }
  }
  
  if [service_name] == "encounter-service" {
    mutate {
      add_field => { "component" => "encounter" }
      add_field => { "system" => "his" }
    }
  }
}

output {
  # Elasticsearch output
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "his-logs-%{+YYYY.MM.dd}"
    template_name => "his-logs"
    template_pattern => "his-logs-*"
    template => {
      "index_patterns" => ["his-logs-*"]
      "settings" => {
        "number_of_shards" => 1
        "number_of_replicas" => 0
      }
      "mappings" => {
        "properties" => {
          "@timestamp" => { "type" => "date" }
          "service_name" => { "type" => "keyword" }
          "component" => { "type" => "keyword" }
          "level" => { "type" => "keyword" }
          "logger" => { "type" => "keyword" }
          "thread" => { "type" => "keyword" }
          "message" => { "type" => "text" }
          "log_message" => { "type" => "text" }
        }
      }
    }
  }
  
  # Debug output (kann sp√§ter entfernt werden)
  stdout { 
    codec => rubydebug 
  }
}
EOF

# 4. Kibana Konfiguration
print_status "Creating Kibana configuration..."
cat > elk-config/kibana/kibana.yml << 'EOF'
server.name: kibana
server.host: 0.0.0.0
server.port: 5601
elasticsearch.hosts: [ "http://elasticsearch:9200" ]
monitoring.ui.container.elasticsearch.enabled: true

# Dashboard und Index Pattern Konfiguration
kibana.index: ".elvs-kibana"
logging.appenders:
  console:
    type: console
    layout:
      type: json
EOF

# 5. Filebeat Konfiguration
print_status "Creating Filebeat configuration..."
cat > elk-config/filebeat/filebeat.yml << 'EOF'
filebeat.inputs:
# HIS Application Logs
- type: log
  enabled: true
  paths:
    - /usr/share/filebeat/logs/gateway/*.log
    - /usr/share/filebeat/logs/patient/*.log
    - /usr/share/filebeat/logs/encounter/*.log
  fields:
    logtype: application
    system: his
  fields_under_root: true
  multiline.pattern: '^\d{4}-\d{2}-\d{2}'
  multiline.negate: true
  multiline.match: after

# Docker Container Logs
- type: container
  enabled: true
  paths:
    - '/var/lib/docker/containers/*/*.log'
  processors:
    - add_docker_metadata:
        host: "unix:///var/run/docker.sock"

# Output zu Logstash
output.logstash:
  hosts: ["logstash:5044"]

# Processors
processors:
  - add_host_metadata:
      when.not.contains.tags: forwarded
  - add_docker_metadata: ~
  - add_kubernetes_metadata: ~

# Logging Level
logging.level: info
logging.to_files: true
logging.files:
  path: /var/log/filebeat
  name: filebeat
  keepfiles: 7
  permissions: 0644
EOF

# 6. Elasticsearch Index Template erstellen
print_status "Creating Elasticsearch index template..."
cat > elk-config/elasticsearch-template.json << 'EOF'
{
  "index_patterns": ["his-logs-*"],
  "settings": {
    "number_of_shards": 1,
    "number_of_replicas": 0,
    "index.refresh_interval": "5s"
  },
  "mappings": {
    "properties": {
      "@timestamp": {
        "type": "date"
      },
      "service_name": {
        "type": "keyword"
      },
      "component": {
        "type": "keyword"
      },
      "level": {
        "type": "keyword"
      },
      "logger": {
        "type": "keyword"
      },
      "thread": {
        "type": "keyword"
      },
      "message": {
        "type": "text",
        "analyzer": "standard"
      },
      "log_message": {
        "type": "text",
        "analyzer": "standard"
      },
      "container": {
        "properties": {
          "name": {"type": "keyword"},
          "id": {"type": "keyword"}
        }
      }
    }
  }
}
EOF

# 7. Kibana Dashboard-Konfiguration erstellen
print_status "Creating Kibana dashboard configuration..."
mkdir -p elk-config/kibana/dashboards

cat > elk-config/kibana/dashboards/his-dashboard.json << 'EOF'
{
  "dashboard": {
    "id": "his-overview",
    "title": "HIS System Overview",
    "description": "Hospital Information System - Service Overview",
    "version": 1,
    "timeRestore": true,
    "timeTo": "now",
    "timeFrom": "now-1h"
  }
}
EOF

print_success "ELK configuration files created successfully!"

echo ""
echo "üìã Created Configuration Files:"
echo "  ‚Ä¢ elk-config/logstash/config/logstash.yml"
echo "  ‚Ä¢ elk-config/logstash/pipeline/logstash.conf"
echo "  ‚Ä¢ elk-config/kibana/kibana.yml"
echo "  ‚Ä¢ elk-config/filebeat/filebeat.yml"
echo "  ‚Ä¢ elk-config/elasticsearch-template.json"
echo ""
echo "üöÄ Next Steps:"
echo "  1. Update docker-compose to use original ELK configuration"
echo "  2. Start ELK services: docker-compose -f docker-compose.dev.yml up elk"
echo "  3. Access Kibana: http://localhost:5601"
echo ""
```

